'$sleepscore 703| Sleep scoring script
'===========================================================================================================
'CAMBRIDGE ELECTRONIC DESIGN LIMITED, THE SCIENCE PARK, MILTON RD., CAMBRIDGE CB0 0FE, UK
'===========================================================================================================

'	Copyright Â© Cambridge Electronic Design,  Dec 2004.
'	Original Author:	GH.
'         last modified :   26/09/2017
'   Modified by: rciszek
'          last modified : 30/9)2017
'	SOFTWARE REQUIRED: Spike 2 version 7.10 or higher

'	HEALTH WARNING:
'	The script is a -work in progress- and is offered without guarantees.
'	You must test it to see whether it is suitable for your application.

'	OVERVIEW
'	This script is intended for subdividing a data file containing polygraph data into epochs
'	of the desired duration. You can step through the data epoch by epoch assigning sleep states
'	based on visual inspection of the recordings. You have the option generate trend plots of
'	EEG power in bands and to view power spectra of selected channels for the current epoch
'	as an aid to determining the sleep stage. 
'	The epochs are stored in the file as a Textmark channel in States mode, the states being
'	colour coded to allow the different sleep stages to be easily distinguished.
'	The sleep states can also be plotted in Skyline mode as a Hypnogram.
'	You can mark arousals, and respiratory or other significant events on a separate Marker channel.
'	You can generate a table of results showing the amount of time spent in different sleep stages
'	and a full epoch by epoch report of sleep stages, events and EEG power in bands
'	for further analysis with spreadsheet software.

'	See user guide: Sleepscore v703.pdf for further information.

proc Revisions()                                        ' Revision History only
'Nov 2013
'modified EvtMouse%()  . no longer shows Cursor 1. We cannot capture the mouse when user clicks on an existing cursor
'EvtUp%() modified for v8 compatibility

'Jan 2014
'path to location for creating external binary files now explicitly defined. previously the script could crash
'if Spike2 was installed in Program files and script tried to create files inside this folder which is not allowed.
'Power in band trend plots are now created using the spectral functions of Virtual channels
'Total power trend plot is also shown automatically in a Virtual channel.
'You can now print Power in bands info in the report even if the Trend plots were not created originally.
'The script creates temporary hidden trend plots as the basis for the report and deletes them afterwards.
'Note that Trend plots ALWAYS show power whereas individual power spectra may show power or %total power
'depending on what was selected in the setup dialogs
'Unstaged gaps in the data are now reported correctly. Previously, they were wrongly labelled with the type of the last
'explicitly assigned stage.
'Script no longer crashes if you decided to create some "Events" after viewing a report.
'Previously, the Report set up dialog could set the Event channel to zero (if None was selected) and this could cause the script to hang up.
'Now the dialog has a checkbox to select the option of printing event info and this checkbox is disabled if no event channel exists.
'Feb 2014
'The report now has an option to print "per cent of total power in each band as well as actual power in each band.
'March 2015
'added Tooltips to all script toolbar buttons
'fixed a bug in Up%() which could cause all epochs in a file to be set to the same state if user released the mouse button while
'Cursors 1 and 2 were simultaneous.

'Feb 2016 'Allow function extended to allow almost everything while dialogs, toolbars and interact bars are in force.
'Sept 2016 Event and sleep stage help now shown in text files rather than dialogs. The Help dialogs blocked some of the toolbar mouse functions when open.
'Added tips to buttons in the Event and Sleep stage Drag and drop control panels.

'Sep 2016
'The script adds a hotkey to the script bar.
'Dialogs now have an improved method of setting time ranges.
'The report has been extended to include the sequence of stages and duration of sleep episodes (hypnogram).
'There is also a sequence of Events option. These options are now selected via check boxes.
'Help for the drag and drop interface now prints to a text file rather than a dialog.
'Control panels for adding events and sleep stages have been rolled into one in order to speed up the scoring process.
'A Preferences button allows you to set the amount of overlap between pages when using the Next / Previous page buttons.
'You can also opt to add Vertical markers at the start and end of Events.
'Empty sleep stage channels are now deleted when you Quit.
'Most dialogs now remember the positions that you dragged them to.

'Oct 2016
'Previously, the on-screen measurement tool using Alt+click and drag did not work while the "Mark Stages and Events" dialog was open.
'This problem has now been fixed.
'The PREFERENCES dialog now allows you to specify the initial time range to display in epochs.
'Epochs are now only shown for the selected time range. Previously, epochs were shown from 0 to MaxTime() irrespective of the time range selected 
'in the SETUP dialog.
'Dialog created with the DlgDesign script have been replaced with simpler hand-crafted code that should be easier to understand and modify.
'Clicking on NewFile could show a spurious warning about unsaved memory buffers if the current time view contained Virtual channels. This problem has been fixed.
'Existing hypnogram channel on disk is now converted to a memory buffer when the Mark Events dialog is opened and saved to disk when it is closed.
'Previously, the hypnogram channel failed to update if the Mark Stages and Events dialog was opened multiple times.
'You can now print a report of previously analysed data by clicking the Report button directly. Before, you had to go through the SEtup procedure 
'in order to enable the Report button.
'The time taken to print the report has now been reduced. Previously, printing Percent power from Virtual channelswas excruciatingly slow. Copying the data
'to memory buffers and printing the contents is much quicker.

'26/09/2017 fixed a bug in EChange%() that caused a failure to recognise that an epoch marker was a memory buffer in Spike 9. (channel numbers range of
'memory buffers changed).

'30/09/2017 (rciszek): Added support for movement classification. 
end;

#include "ghutils.s2s"
var tab%:=15;                                           ' set tabstop for text files here
const on%:=1,off%:=0,all%:=-1;
const swquit%:=1,swnew%:=2,swsetup%:=3,swAn%:=5, swcmt%:=7; ' button numbers
const swcmtEv%:=8,swAM%:=11,swrep%:=13;  

var c1itm%,c2itm%;                                      ' dialog item numbers linked to cursors

'	Variables needed for dialogs made with DlgDesign script
var okk%,nn%,ng%[20],nt%[200];
var dit%[101],dbn%[101];                                ' item numbers for dlgitems and dlg buttons
var dxp[9],dyp[9],dd%,dlgx$,dlgy$;                      ' dialog coordinates kept in Profile
var sshlpvh%;                                           ' event and sleep stage  help text view handles
var errwav$:="C:\\WINDOWS\\MEDIA\\Musica Error.wav";
var key$:= "slpsmvmcore705";                               ' registry key for default settings
var prf$,trep%;
var pov%,vmchk%,vmflags%,usecolchk%,showchk%,nofillchk%;
var prompt$:="Sleep and movement classification script";                    ' 
var timevh%,title$,i%;
var reptchk%[8];                                        ' checkboxes indicating scope of report

var epstart,epend,epdur,epdur$,epch%;
var ssch%,comment$,evpos,codes%[4],lastevp;     
var ch;
var nstates%;                                           ' number of stages used
var option%;                                            ' stores selected button set (1,2 or 3)

var st,nd;
var setupdone%:=0;                                      ' flag that set up was done
var evtch%;                                             ' events marker channel
var note$;                                              ' note attached to an event

var swbtns%;                                            ' flag show stage buttons dialog
var evbtns%;                                            ' flag show event buttons dialog
var evbtnlbl2$[10],evlbl2$[10],evtypes%;                ' user-defined event buttons and state labels and flag
var hypch%;

var s$[7],s2$[7];                                       ' default and user-defined stage button labels 
var slab$[7],slab2$[7];                                 ' stage labels for the states
var chk0%,chk1%,chk2%,chk3%;
var col%[4];   

var nmovements% := 13;                                  ' the number of default movement types
var movement_labels$[nmovements%];                      ' movement button label array
' definition of movement button labels
movement_labels$[0]:= "Movement";	                    
movement_labels$[1]:= "Drinking";  
movement_labels$[2]:= "Scratching";
movement_labels$[3]:= "Grooming";
movement_labels$[4]:= "Tonic-clonic";
movement_labels$[5]:= "Tonic";
movement_labels$[6]:= "Clonic";
movement_labels$[7]:= "Myoclonus";
movement_labels$[8]:= "Clonus";
movement_labels$[9]:= "Wandering";
movement_labels$[10]:= "Exploring";
movement_labels$[11]:= "Eating";
movement_labels$[11]:= "Automatism";
movement_labels$[12]:= "Chewing";

var movement_tlast;                                     ' start time of most recently added movement
var mvmch%;                                             ' movements marker channel                             
var mvmflg%;                                            ' flag for start (0)/end (1) of movement

' colours for power bands

'	Power spectrum variables
var PSchan%,fftszndx%,uf,nbns%,fftwinndx%,Tfft,bwHz;
var fftnrarr%[11];                                      ' array of FFT numbers

var selchlst%[33];                                      ' list of selected channels
var bw;                                                 ' binwidths for power spectra
var prev%;                                              ' count of previously selected channels
var updflag%,psonoff%,psvh%,ps2vh%;
var edgebin[5],edgebin%[5],edgeHz[5],edgeHz$[5];        ' edges of power bands in bins and in Hz
var hibin%[4],lobin%[4];
var bandlbl$[4];
var powpctchk%,trendchk%;                               ' selectors for pow/%pow and trendplots

var tick;                                               ' time resolution of current file
var version;
var evtflg%;                                            ' flag for start (0)/end (1) of event
var tlast;                                              ' start time of most recently added event
var btnnr%;
var redostagesflg%;                                     ' allow user to change to different stage selection buttons  if they don-t match the current epoch channel
var hypchk%;                                            ' create hypnogram check box
var lastc$;                                             ' previous sleep stage comment
var acode%;                                             ' selected marker code for auto add event markers
var dirflg%:=0;                                         ' 0 for auto-advance; 1 for auto-reverse (only applies if Xrange is less than 2 epochs)
var scope%;                                             ' scope of report
var path$;
var ttl$[5];
ttl$[0]:="delta";	ttl$[1]:="theta";
ttl$[2]:="alpha";	ttl$[3]:="beta"; ttl$[4]:="P.tot";
var script$,set$;                                      

script$:=View(App(3)).FileName$(0);                     ' full name of script -including volume and path
set$:="SlpMvmSc|"+script$+"|Manual sleep and movement scoring script"; ' label for script bar button
'-------------------------------------------------------------------------------------------
AddScriptBarBtn%(set$);                                 ' comment this line if you do not want to add a button to the Script bar
'-------------------------------------------------------------------------------------------

version:=App(-1)/100.0;
if version < 7.10 then
    Message("Spike2 version: "+Str$(version)+" detected|This script requires Spike2 version 7.10 or higher.\n"+
    "Please download and install the latest free Spike2 upgrade from www.ced.co.uk. Then run the script again");	
    halt
endif;

'	needed for dialogs created with dialog design script
for i%:=1 to 100 do                                     ' fill arrays of dialog item and button numbers
    ' for use by DlgVisible() and DlgEnable();
    dit%[i%]:=i%;                                       ' load dlgitems array.
    dbn%[i%]:=-i%;                                      ' ditto dlg buttons...
next;

col%[0]:=14; col%[1]:=15;col%[2]:=16;col%[3]:=20;       ' set band colours: green, blue, red, brown.
bandlbl$[0]:="Delta";bandlbl$[0]:="Theta";bandlbl$[0]:="Alpha";bandlbl$[0]:="Beta";

ProfileGet();
for i%:= 4 to 14 do
    fftnrarr%[i%-4]:=Pow(2,i%);                         ' generate array of fft sizes
next;

Profile(key$,"Prefs","5,0,0,1",prf$);                   ' get current preferences
ReadStr(prf$,pov%,vmchk%,vmflags%,trep%);
Profile(key$,"Dlgxpos","0,0,0,0,0,0,0,0,0",dlgx$);
Profile(key$,"Dlgypos","0,0,0,0,0,0,0,0,0",dlgy$);
ReadStr(dlgx$,dxp[0],dxp[1],dxp[2],dxp[3],dxp[4],dxp[5],dxp[6],dxp[7],dxp[8]); ' read stored dialog coordinates from Profiel
ReadStr(dlgy$,dyp[0],dyp[1],dyp[2],dyp[3],dyp[4],dyp[5],dyp[6],dyp[7],dyp[8]);

Colour(26,21);                                          ' use pale yellow as default colour	for epochs of state 8 (blank)
timevh%:=View();
path$:=FilePath$(1);                                    ' path to newly created spike2 files (we can use this path for opening binary files);
HideApps();
View(Loghandle());                                      ' clear the log window
TabSettings(tab%);                                      ' set tab size for table (tab% is a global  variable)
EditSelectAll();
EditClear();
WindowVisible(2);                                       ' iconise log
DoToolbar();
RestoreApps();                                          ' restore screen to its original state
halt;
'===

func Prefs%()
var ok%;

dd%:=5;
DlgCreate("Preferences",dxp[dd%],dyp[dd%]);
DlgAllow(511,0,PChnge%);
DlgInteger(1,"Overlap between pages (%)|Range 0 to 50 percent",0,50,0,0,5);
DlgInteger(2,"Page width (epochs)",1,20,0,0,1);
DlgGroup("Vertical Markers",1,3,40,5);
DlgCheck(3,"Markers at start and end of 'Events'.",0,4);
DlgCheck(4,"Use State colours.",0,5);
DlgCheck(5,"Show Text",0,6);
DlgCheck(6,"Hide fill behind text.",0,7);
DlgButton(1,"OK|0x0d",MyOK%);
DlgButton(0,"Cancel",MyCancel%);
ok%:=DlgShow(pov%,trep%,vmchk%,usecolchk%,showchk%,nofillchk%);
if ok%<=0 then return 1; endif;
if vmchk%=0 then
    VerticalMark(0);                                    ' cancel any previously set Vertical Marks.
endif;
vmflags%:=2*usecolchk%+4*showchk%+16*nofillchk%;
prf$:=Print$("%d,%d,%d,%d",pov%,vmchk%,vmflags%,trep%); ' update preferences
Profile(key$,"Prefs",prf$);
return 1;
end;

func PChnge%(item%)
DlgEnable(DlgValue(3),4,5,6);
return 1;
end;

func AutoMark%()                                        ' auto mark sleep apneas based on threshold crossings
var ok%,s,e,t,t2;   
var time,lvl,lbl$,code%[4],acode%;                          
var automark$,i%,pos%;       
var stch%,ab%;
var evlbl$[evtypes%];

Profile(key$,"automk","0,0,3,0",automark$);             ' get default values of threshold, time and  marker code for selected event type
ReadStr(automark$,lvl,time,acode%,ab%);                 ' extract values from stored string
View(timevh%);

for i%:=0 to evtypes%-1 do
    pos%:=InStr(evbtnlbl2$[i%],"|");
    if pos%>0 then
        evlbl$[i%]:=Left$(evbtnlbl2$[i%],pos%-1);
    endif;     
next;

if e=0.0 then e:=MaxTime(); endif;

dd%:=3;
DlgCreate("Auto-Mark",dxp[dd%],dyp[dd%],70);
c1itm%:=6;
c2itm%:=7;
DlgAllow(511,AMidl%,AMChnge%);
DlgChan(1,"Source Channel",1+512+2048+4194304);         ' visible,  waveform/RealWave channel +short titles
DlgList(2,"Label States as...",evlbl$[],evtypes%);
DlgGroup("Threshold",1,2.8,67,3);
DlgText("Criteria",2,3.7);
DlgList(3,10," Above| Below",2,12,3.7);
DlgReal(4,13,-1e9,1e9,25,3.7,0.1);
DlgText("for at least",41,3.7);
DlgReal(5,10,0.0,10.0,54,3.7,0.02);                     ' min time
DlgText("(s)",65,3.7);
DlgText("TIP:   Drag the horizontal cursor to adjust threshold level.",11,4.9);

DlgGroup("Time range",1,6.3,67,3.9);
DlgText("Start time (s)",2,7.2);
DlgText("End time (s)",2,8.2);
DlgReal(6,16,0,MaxTime(),-3,7.2,1);
DlgReal(7,16,0,MaxTime(),-3,8.2,1);
DlgText("TIP:    Drag vertical cursors to adjust the time range.",20,9.3);

DlgButton(2,"   Zero   ",C1Zero%,20,7.2);
DlgButton(3,"Fetch Csr1",FetchCsr1%,33,7.2);
DlgButton(4,"MaxTime",C2MaxT%,20,8.2);
DlgButton(5,"Fetch Csr2",FetchCsr2%,33,8.2);
DlgButton(0,"Cancel",MyCancel%);
DlgButton(1,"OK|0x0d",MyOK%);
ok%:=DlgShow(stch%,acode%,ab%,lvl,time,s,e);
if ok%<=0 then return 1; endif;
acode%+=1;
'check the current state channel : Time range must be empty
if Count(evtch%,s,e)>0 then
    Message("Error| This time range already contains state markers.\n"+
    "Delete existing states or go to SETUP and create a new empty State channel.");
    return 1;
endif;
var newch%;
if ChanKind(evtch%)=8 and InStr(Chan$(evtch%),"m")=0 then ' if evt chan is a disk-based channel 
    newch%:=MemChan(0,evtch%);                          ' copy to an editable channel
    DrawMode(newch%,15,2);                              ' states mode with labels
    MemImport(newch%,evtch%,0.0,MaxTime());             ' import events
    ChanDelete(evtch%);                                 ' delete permanent channel
    evtch%:=newch%;                                     ' re-assign channel number variable
endif;
ChanShow(evtch%);



automark$:=Print$("%.1f,%.1f,%d,%d",lvl,time,acode%-1,ab%); ' encode new values as a string 
Profile(key$,"automk",automark$);                       ' store for next time

docase
case ab%=0 then                                         ' above threshold
    MemImport(evtch%,stch%,s,e,2,time,lvl,acode%);      ' data rising through level  '(apply minimum duration)   +0.1
    MemImport(evtch%,stch%,s,e,3,0,lvl,0);              ' data falling through level (end)
case ab%=1 then                                         ' below threshold
    MemImport(evtch%,stch%,s,e,3,time,lvl,acode%);      ' data falling through level  '(apply minimum duration)   +0.1
    MemImport(evtch%,stch%,s,e,2,0,lvl,0);              ' data rising through level (end)    
endcase;

'cope with channel being already over threshold at start of time range
NextTime(evtch%,s,code%[]);
if code%[0]=0 then                                      ' first marker in time range is a terminator
    code%[0]:=acode%;
    MemSetItem(evtch%,0,s,code%[]);                     ' begin first state at onset of time range
endif;

'Now we do a loop to tidy up by removing epochs that are too short
t := s;                                                 ' start at stime
t := NextTime(evtch%, t);                               ' Go to the first actual marker
while (t < e) and (t >= 0.0) do
    t2 := NextTime(evtch%, t);                          ' Following marker
    if ((t2 < e-BinSize()) and (t2 > 0) and ((t2-t) < time)) then
        MemDeleteTime(evtch%, 0, t, BinSize(stch%));
    endif
    t := t2;                                            ' Move on to the next time
wend;
'And a second loop to tidy up the situation where we now have two
'adjacent markers with the same classification code.
var cd2%[4];                                            ' Second marker code data
t := s;                                                 ' start at stime again
t := NextTime(evtch%, t, code%[]);                      ' Go to the first actual marker
while (t < e) and (t >= 0.0) do
    t2 := NextTime(evtch%, t, cd2%[]);                  ' Following marker
    if ((t2 < e-BinSize()) and (t2 > 0) and (code%[0] = cd2%[0])) then
        MemDeleteTime(evtch%, 0, t2, BinSize(stch%));
    else
        t := NextTime(evtch%, t, code%[]);              ' Move on to the next time
    endif
wend;
var c%[4];
LastTime(evtch%,e,c%[]);
if c%[0]<>0 then
    c%[0]:=0;
    ok%:=MemSetItem(evtch%,0,e,c%[]);
endif;                                                  ' add terminator at etime if necessary

t:=s-BinSize();                                         ' start just before stime
lbl$:=Print$("%s  ch:%d<%.1f%",evlbl2$[acode%-1],stch%,lvl); ' label with the threshold
repeat
    t:=NextTime(evtch%,t,code%[]);                      ' add labels to the marked states
    if code%[0] = acode% then
        MarkEdit(evtch%,t,code%[],lbl$);
    endif;
until t > e or t < 0.0;

newch%:=ChanSave(evtch%,0);    
ChanOrder(evtch%,1,newch%);                             ' move newly created disk channel next to memory buffer
ChanShow(newch%);                                       ' show it
ChanDelete(evtch%);                                     ' delete buffer
evtch%:=newch%;                                         ' keep same variable name for the channel
if vmchk% then
    VerticalMark(evtch%,vmflags%,-1,-1,-1);
endif;
return 1;
end;

func AMidl%()
LinkCsrToDlg(6,1,timevh%);                              ' link cursors 1 and 2 in source file to the dialog
LinkCsrToDlg(7,2,timevh%);
if Cursor(1)>Cursor(2) then
    CursorRenumber();
endif;
LinkHCsrToDlg(4,1,DlgValue(1),timevh%);                 ' link hcursor 1 to dialog
return 1;
end;

func AMChnge%(item%)
var pos,ystp,ch%,hc%,hcok%;

if item%=0 or item%=1 then
    ch%:=DlgValue(1);
    pos :=YLow(ch%)+(YHigh(ch%)-YLow(ch%))*0.5;         ' truncate to 5 dec places so it fits in the dialog box
    ystp:=Trunc(YHigh(ch%)-YLow(ch%)*1e5);
    ystp/=1e7;                                          ' 1% of y-range    
    DlgValue(2004,ystp);                                ' spinner step to 2% of y-range
    
    if HCursorExists(1) then
        if HCursorChan(1)=DlgValue(1) then hcok%:=1; hc%:=1; endif; ' if existing hcursor is in the correct channel then use it
    endif;
    if hcok%=0 then                                     ' else start with a freash hcursor
        HCursorDelete(-1);
        hc%:=HCursorNew(DlgValue(1),pos);               ' hc at mid-range
    endif;    
    HCursorLabel(4,hc%,"Threshold: %.1p");
    HCursorLabelPos(hc%,5);
endif;

if item%=4 then DlgEnable(2,0); endif;                  ' focus away from level box so number is not highlighted (easier to read)

LinkDlgToCsr%(item%,6,1,timevh%);                       ' link times in dialog to cursor in source file
LinkDlgToCsr%(item%,7,2,timevh%);
CursorRenumber();
LinkDlgToHcsr(item%,4,1,Dlgvalue(1),timevh%);
return 1;
end;

func C1Zero%()                                          ' button to toggle stime in Copy/Paste dialog
var vh%;                                                ' cpos,

vh%:=View();
View(timevh%);
DoCursors(2);                                           ' don-t let user get away with deleting the cursors that we need
Cursor(1,0.0);
DlgValue(c1itm%,0.0);
View(vh%);	
return 1;
end;

func C2MaxT%()                                          ' button to toggle etime in Copy/Paste dialog
var vh%; 

vh%:=View();
View(timevh%);
DoCursors(2);
Cursor(2,MaxTime());
DlgValue(c2itm%,MaxTime());
View(vh%);
return 1;
end;

func FetchCsr1%()                                       ' Copy/Paste dialog button
var t,vh%;

vh%:=View();
View(timevh%);
DoCursors(2);
t:=XLow()+0.3*(XHigh()-XLow());
Cursor(1,t);
DlgValue(c1itm%,t);
View(vh%);
return 1;
end;

func FetchCsr2%()                                       ' Copy/Paste dialog button
var t,vh%;

vh%:=View();
View(timevh%);
DoCursors(2);
t:=XLow()+0.7*(XHigh()-XLow());
Cursor(2,t);
DlgValue(c2itm%,t);
View(vh%);
return 1;
end;

proc DoCursors(nc%)                                     ' set up one or two static cursors in time view
var i%,n%,num%;

n%:=nc%+1;
CursorVisible(0,0);                                     ' hide cursor zero
repeat
	num%:=CursorDelete(n%);
	if num%>0 then n%+=1; endif;                        ' delete cursors 3 to 9	
until num%=0 or n%=9;

for i%:=1 to nc% do
	if CursorExists(i%) then
		CursorActive(i%,0);                             ' force static mode
		CursorVisible(i%,1);                            ' make sure we can see cursors
	else
		CursorNew(XLow()+((XHigh()-XLow())*i%/3.0),i%);		
	endif;
next;
CursorRenumber();
if nc%=2 then
    CursorLabel(3,1);                                   
    CursorLabelPos(1,2);
	CursorLabel(3,2);                                   
	CursorLabelPos(2,4);
endif;
return;
end;

proc DoToolbar();                                       ' create toolbar
var n%,vlist%[50];
Buttons1%();
FindView(timevh%,0);
'if ViewKind(timevh%) <> 0 then                          ' if current view not a time view
'    n%:=ViewList(vlist%[],1);                           ' look for a non-current open time view
'    if n% >= 1 then                                     ' found one
'        timevh%:=vlist%[1];
'    endif;
'endif;
if ViewKind(timevh%) = 0 then                           ' if we found a time view
    View(timevh%);                                      ' use it as default data file
    FileSetup();
else                                                    ' otherwise user must browse to a datafile
endif;
DoButtons%("offx","",swquit%,swnew%,15,swrep%,0,0);
Toolbar(prompt$,511);
return;
end

func Buttons1%();                                       ' buttons on main toolbar
ToolbarClear();
ToolbarSet(0,         	"",Idle1%);
ToolbarSet(swquit%,		"&Quit||Hotkey: Q",Quit%);
ToolbarSet(swnew%,		"&New File||Hotkey: N. Browse to and open a new time view",NewFile%);
ToolbarSet(swsetup%,  	"Set-&Up||Hotkey: U. Prepare to score polygraph data",Setup%);
ToolbarSet(swAn%,     	"Mark &Stages and Events||Hotkey: S.",StagesDlg%);
ToolbarSet(swcmt%,       "Stage &Comment||Hotkey: C. Add a comment to a sleep stage.",Commentbtn%);
ToolbarSet(swcmtEv%,     "E&Vent Comment||Hotkey: V. Add comment to an Event.",CommentEv%);
ToolbarSet(swAM%,        "&Auto Mark Events||Hotkey: A. Auto mark events such as low SaO2",AutoMark%);
ToolbarSet(swrep%,		"&Report||Hotkey: R. Generate a table of results",Report%);
ToolbarSet(15,"Preferences",Prefs%);
return 1;
end;

func UseMouse%()                                        ' functions for setting sleep  stages using the mouse
var i%,b%, n%:=6,xp:=3,yp:=3,xofs:=12,tst%;             ' 3.6
var done%;

n%:=0;
repeat
    if n%=7 then break; endif;
    if Len(s2$[n%])=0 then break; endif;    
    n%+=1;                                              ' count the number of buttons that were defined
until done%;
n%-=1;

if vmchk% then
    VerticalMark(evtch%,vmflags%,-1,-1,-1);
endif;

dd%:=0;
DlgCreate("Mark Stages / Events",dxp[dd%],dyp[dd%],90,15);
DlgAllow(511,0,UseMouseChnge%);
DlgGroup("Current selection",37,0.9,16,1.5);
nt%[0]:=DlgText("TEST",40,1.5,12);
DlgGroup("Select Sleep Stage",2,2,85,2);
b%:=1;
for i%:=0 to n% do
    b%+=1;
    DlgButton(b%,s2$[i%],Evbtnfnc%,xp,yp);
    xp+=xofs;    
next;
yp+=1.5;
DlgGroup("Select Event",2,yp,85,3);
xp:=3;
yp+=1;
for i%:=0 to evtypes%-1 do
    b%+=1;
    DlgButton(b%,evbtnlbl2$[i%],Evbtnfnc%,xp,yp);
    if i%>0 and (i%+1) mod 7 =0 then                    ' buttons in rows of 7
        yp+=1;  xp:=3;                                
    else
        xp+=xofs;
    endif; 
next;
tst%:=i% mod 5;
if i% mod 7<>0 then   yp+=1.4; endif;
'yp+=1;
DlgGroup("Select Movement",2,yp,85,4);
xp:=3;
yp+=1;
'Display the buttons for movement classification
var m_xofs:=13; 'Use wider offset for movement buttons
for i%:=0 to nmovements%-1 do
    b%+=1;
    DlgButton(b%,movement_labels$[i%],mvbtnfnc%,xp,yp);
    if i%>0 and (i%+1) mod 6 =0 then                    ' buttons in rows of 6 for movement
        yp+=1;  xp:=3; 
    else
        xp+=m_xofs;
    endif;
next;
yp+=2;

DlgGroup("Navigation",14,yp,50,2);
xp:=3;
b%+=10;
xp:=15;
yp+=1;
DlgButton(b%,"Start|0x26|Go to first page. Hotkey: <up arrow>",St%,xp,yp);
xp+=xofs-1; b%+=1;
DlgButton(b%,"<- Previous|0x25|Back to previous page. Hotkey: <-",PageLeft%,xp,yp);
xp+=xofs+2; b%+=1;
DlgButton(b%,"   Next ->  |0x27|Forward to next page. Hotkey: ->",PageRight%,xp,yp);
xp+=xofs+3; b%+=1;
DlgButton(b%,"  End  |0x28|Go to last page. Hotkey: <dwn arrow>",Nd%,xp,yp);
b%+=1;
DlgButton(b%,"&Help||Click to display Drag and Drop guide. Click again to hide it.",EvSShelp%,-13,yp);
xp+=xofs-1; b%+=1;
DlgButton(1,"Close|0x0d|hotkey: <Enter>",MyOK%,-3,yp);
DlgButton(0,"");
DlgMouse(timevh%,0,1+128,1,DoDown%,DoUp%,DoMove%);      ' tell the script about Alt so we can keep the caliper tool working
DlgShow();
if ViewKind(sshlpvh%)=1 then
    View(sshlpvh%);
    FileClose(0,-1);
endif;
Back%();
return 1;
end;

func MyOk%();
DlgGetPos(dxp[dd%],dyp[dd%]);                           ' save dialog coordinates to array at the time it was closed 
return 0;
end;

func MyCancel%();
DlgGetPos(dxp[dd%],dyp[dd%]);                           ' save dialog coordinates to array at the time it was closed 
return -1;
end;

func UseMouseChnge%(item%)
var lbl$,n%,spacer$,a%,i%;

if item%=0 then                                         ' virtual press of first stage button when dialog opens
    btnnr%:=2;
    n%:=InStr(s2$[btnnr%-2],"|");
    if n%>1 then     
        lbl$:=Left$(s2$[btnnr%-2],n%-1);                ' Removal tooltip and code from the label
    else
        lbl$:=s2$[btnnr%-2]; 
    endif;
    ToolbarText(Print$("Current selection:   %s",UCase$(lbl$))); ' show current selection on the toolbar
    a%:=(16-Len(lbl$))*0.5;
    for i%:=1 to a% do
        spacer$+=" "; 
    next;
    DlgValue$(nt%[0],spacer$+UCase$(lbl$));
endif;
return 1;
end;

func EvSShelp%()
var vh%;

if ViewKind(sshlpvh%)=1 then                            ' help view exists
    View(sshlpvh%);                                     ' close it
    FileClose(0,-1);
else                                                    ' help view does not exist so create it.
    vh%:=View();
    sshlpvh%:=FileNew(1,0);
    WindowTitle$("Help");
    Window(0,58,80,100);
    Print("SLEEP STAGES\n1.  Click on a STAGE button in the control panel or its hotkey to select a sleep stage.\n"+
    "2.  Hold down CTRL and click in the time view to apply the current sleep stage.\n");
    Print("3.  Drag left or right to mark multiple epochs.\n"+
    "4.  Press SHIFT and click on an epoch marker to show a banded power spectrum for that epoch. (if selected)\n"+
    "5.  Shift + Click again in the same epoch to hide the previous power spectrum.\n"+
    "6.  Press ALT + click and drag to make on-screen measurements of waveform amplitudes and durations.\n\n");
    
    Print("EVENTS.\n1.   Click on an EVENT button or its hotkey to select an Event type.\n"+
    "2.  Hold down CTRL and click inside the time view to fetch a cursor then drag to the desired start time of an Event.\n");
    Print("3.  Release the mouse button to mark the Start of an Event.\n"+
    "4.  Hold down CTRL and click and drag again in the \"Evts\" channel to set the end time of the current event when you\n"+
    "    release the mouse button.\n");
    Print("5.  CTRL+click + release to the left of the start of an un-terminated Event to delete it.\n"+
    "6.  Hold down SHIFT and click inside an Event with a user-defined end time to delete it. (Current selection must be an Event!)\n");
    Print("7.  Hold down CTRL+SHIFT and click inside an Event to CHANGE its type to the currently selected event type.\n");    
    FrontView(sshlpvh%);
endif;
View(vh%);
return 1;
end;

func St%()
var xpage;

View(timevh%);
xpage:=XHigh()-XLow();
XRange(epstart,epstart+xpage);
return 1;
end;

func Nd%()
var xpage;

View(timevh%);
xpage:=XHigh()-XLow();
XRange(epend-xpage,epend);
return 1;
end;

func PageRight%()
var xpage,poverlap;

View(timevh%);
poverlap:=pov%/100.0;
xpage:=(XHigh()-XLow())*(1.0-poverlap);
XRange(XLow()+xpage);
dirflg%:=0;                                             ' flag  auto advance
return 1;
end;

func PageLeft%()
var xpage,poverlap;

View(timevh%);
poverlap:=pov%/100.0;
xpage:=(XHigh()-XLow())*(1.0-poverlap);
XRange(XLow()-xpage);
dirflg%:=1;                                             ' flag  auto reverse
return 1;
end;

func Evbtnfnc%()
var lbl$,n%;

btnnr%:=DlgButton();
n%:=InStr(evbtnlbl2$[btnnr%-nstates%-3],"|");
if n%>1 then     
    lbl$:=Left$(evbtnlbl2$[btnnr%-nstates%-3],n%-1);                    ' Removal tooltip and code from the label
else
    lbl$:=s2$[btnnr%-2]; 
endif;
inner_button_function(lbl$)
return 1;
end;

func mvbtnfnc%()
btnnr%:=DlgButton();
var lbl$:=movement_labels$[btnnr%-evtypes% - nstates% -3]; 
inner_button_function(lbl$)
return 1;
end;

'Function encapsulating operations common to both event and movement buttons
func inner_button_function(lbl$)
    var spacer$,a%,i%;
    ToolbarText(Print$("Current selection:   %s",UCase$(lbl$))); ' show current selection on the toolbar
    a%:=(16-Len(lbl$))*0.5;
    for i%:=1 to a% do
        spacer$+=" "; 
    next;
    DlgValue$(nt%[0],spacer$+UCase$(lbl$));
end;

Func DoMove%(vh%,chan%,x,y,flags%)
docase
case btnnr%>1 and btnnr%<(nstates%+3) then              ' sleep stage selected
    SSMove%(vh%,chan%,x,y,flags%);
case btnnr%>nstates%+2 and btnnr%< evtypes% + nstates% +3 then    
    EvMove%(vh%,chan%,x,y,flags%);   
case btnnr%>=evtypes% + nstates% +3 then    
    EvMove%(vh%,chan%,x,y,flags%);     
endcase;
return 1;
end;

func SSMove%(vh%,chan%,x,y,flags%)
var lvl[1];
lvl[0]:=codes%[0];
if ViewKind(vh%)=0 and flags%=9 then                    ' if CTRL + click on time view
    View(LogHandle()).WindowVisible(2);                 ' iconise log
    if ViewKind(ps2vh%)=4 then
        View(ps2vh%).WindowVisible(2);                  ' iconise power spectrum if there is one
    endif;	
    View(vh%);
    codes%[0]:=btnnr%-1;                                ' cope with fact that buttons 0 and 1 are already used for <Cancel >and <OK>
    if codes%[0]>=0 then                                ' do nothing until a stage button was pressed
        MarkEdit(ssch%,LastTime(ssch%,x),codes%[],slab$[codes%[0]]);
        Cursor(2,NextTime(ssch%,x));
        if ChanKind(hypch%)=7 then
            MemSetItem(hypch%,0,LastTime(ssch%,x),codes%[],lvl[]); ' lots of event mkrs added (superfluous ones deleted on UP)
        endif;
    endif;    
endif;
return 1;
end;

Func EvMove%(vh%,chan%,x,y,flags%)
if vh%=timevh% and flags%=8+1 then                      ' Ctrl+click
    CursorVisible(1,1);
    Cursor(1,x);
endif;
return 1;
end;


func DoUp%(vh%,chan%,x,y,flags%)
docase
case btnnr%>1 and btnnr%<nstates%+3 then                ' sleep stage selected
    SSUp%(vh%,chan%,x,y,flags%);    
case btnnr%>nstates%+2 and btnnr%<evtypes% + nstates% +3 then
    EvUp%(vh%,chan%,x,y,flags%,0, evtch%);                        ' event selected 
case btnnr%>= evtypes% + nstates% +3 then
    EvUp%(vh%,chan%,x,y,flags%,1,mvmch%);                        ' movement selected 
endcase;
return 1;
end;

func DoDown%(vh%,chan%,x,y,flags%)
if ViewKind(vh%)<> 0 then
    return 1;
else
    View(vh%);     
endif;
docase
case btnnr%>1 and btnnr%<nstates%+3 then                ' sleep stage selected
    SSDown%(vh%,chan%,x,y,flags%);    
case btnnr%>nstates%+2 and btnnr%< evtypes% + nstates% +3 then
    EvDown%(vh%,chan%,x,y,flags%,0,evtch%);    
case btnnr%>=evtypes% + nstates% then
    EvDown%(vh%,chan%,x,y,flags%,1,mvmch%);      
endcase;
return 1;
end;

func SSDown%(vh%,chan%,x,y,flags%)                      ' Down-click during Sleep Stage selection
if ViewKind(vh%)=0 and flags%=5 then                    ' if Shift+ click on a time view then
    if psonoff% = on% then
        evpos:= LastTime(ssch%,x);
        if evpos=lastevp then                           ' clicked a second time on same epoch 'so hide power spectrum and table in the log
            View(ps2vh%).WindowVisible(2);
            View(LogHandle()).WindowVisible(2);
            lastevp:=0;
        else
            DoPSProcess();                              ' show power spectrum
            lastevp:=evpos;                             ' remember last epoch processed
        endif;                                          ' show new power spectrum
    endif;
    if flags%<>129 then                                 ' not Alt+click
        CursorSet(2,LastTime(ssch%,x),NextTime(ssch%,x)); ' cursors at start and end of current epoch
    else
        ' allow user to make measurements with Alt+Click caliper tool
    endif;
endif;
return 1;
end;

func EvDown%(h%,chan%,x,y,flags%,event_type%, selected_channel%);                      ' Down-click during Event selection
var lastt,nextt,lastcc%[4],nextcc%[4];
lastt:=LastTime(selected_channel%,x,lastcc%[]);                    ' find out what went before and what comes after
nextt:=NextTime(selected_channel%,x,nextcc%[]);  

var current_label$; 
if event_type% = 0 then
    codes%[0]:=btnnr%-nstates%-2; 
    current_label$ := evlbl2$[codes%[0]-1];
else
    codes%[0]:=btnnr%-evtypes% - nstates% -2;
    current_label$ := movement_labels$[codes%[0]-1];  
endif

docase
case flags%=8+1 then                                    ' if Ctrl +click then
    CursorSet(1,1);                                     ' show cursors at pointer position
    Cursor(1,x);     
case  flags%=4+1 then                                   ' SHIFT +click
    if lastcc%[0]>0 and nextcc%[0]=0 then               ' if pointer is inside an Event
        if nextt<0 then nextt:=MaxTime(); endif;
        MemDeleteTime(selected_channel%,3,lastt,nextt);            ' delete current event
    endif;
case flags%=8+4+1 and codes%[0]> 0 then                 ' if Shift+Ctrl+click  then change <type> of the current event  leaving duration unchanged                      
    if lastcc%[0]>0 then
        MarkEdit(selected_channel%,lastt,codes%[],current_label$); ' change the event type
    endif;
endcase;
Draw();
return 1;
end;

proc MarkEvent(code%,lbl$,bspc$)                        ' add markers and comment to Events channel
var t,t2,codes%[4];
var cca%[4];                                            ' codes of previous and nextmarker rel to Csr1 

View(timevh%);
if CursorExists(1)=0 then
    FetchCsr%();
    return;
endif;

t:=LastTime(evtch%,Cursor(1)+BinSize(),codes%[]);       ' get time and code of last marker
t2:=NextTime(evtch%,Cursor(1)+BinSize(),cca%[]);
docase
case evtflg%=0 and (t<0 or codes%[0]=0) then            ' start event selected and not inside a pre-existing event
    codes%[0]:=code%;
    MemSetItem(evtch%,0,Cursor(1),codes%[],lbl$);       ' mark start of event
    evtflg%:=1;                                         ' flag that we started an event
    tlast:=Cursor(1);                                   ' remember where we put it in case we have to delete it later
    
case evtflg%=1 and (codes%[0]=code% or codes%[0]=0) and Cursor(1)>tlast then
	' IF end of event selected, Cursor is after start of Event, previous marker is a Start for this event type 
    MemDeleteTime(evtch%,3,tlast+BinSize(),Cursor(1));  ' delete all previous events in the time range
    if cca%[0]<>0 or t2<0 then                          ' add a terminator unless cursor inside an existing Event
        codes%[0]:=0;
        MemSetItem(evtch%,0,Cursor(1),codes%[]);        ' mark end of event
    endif;
    
    evtflg%:=0;                                         ' flag that we started an event
else
    Sound(errwav$,1);                                   ' warning that cursor position is not valid
    if evtflg%=1 then
        MemDeleteTime(evtch%,0,tlast);                  ' if user didn-t terminate the current event properly then delete it
        tlast:=0.0;
        evtflg%:=0;
    else
        DoButtons%("on",bspc$,0,0,0,0,0,0);             ' enable all event btns if attempt to start an event marker failed
    endif;
endcase;
note$:="";
return;
end;

func SSUp%(vh%,chan%,x,y,flags%)
var t,lvl[1],null[1],c%[4];
null[0]:=-0.5;                                          ' level at terminator of hypnogm channel
c%[0]:=0;
if ViewKind(vh%)=0 and flags%=8 then                    ' if CTRL +Up
    CursorRenumber();
    ' double check that all epochs in last range were updated   (some epochs may be missed if mouse was dragged quickly)
    if ChanKind(hypch%)=7 then       
        MemDeleteTime(hypch%,3,Cursor(1),Cursor(2)-BinSize()); ' delete all markers except the first
        if NextTime(hypch%,Cursor(1)-BinSize())>Cursor(2) then ' if no following hyp stages
            MemSetItem(hypch%,0,Cursor(2)+BinSize(),codes%[],lvl[]); ' terminate current stage
            MemSetItem(hypch%,0,Cursor(2)+2*BinSize(),c%[],null[]); ' terminate current stage
        endif;          
    endif;
    lvl[0]:=codes%[0];
    t:=LastTime(ssch%, Cursor(1));
    repeat
        t:=NextTime(ssch%,t);
        MarkEdit(ssch%,t,codes%[],slab$[codes%[0]]);
        if ChanKind(hypch%)=7 then          
            MemSetItem(hypch%,0,t,codes%[],lvl[]);
        endif;          
    until t>=LastTime(ssch%,Cursor(2));                 ' bug fix March 2015. -previously t=LastTime()
    
    if ChanKind(hypch%)=7 then
        var tt;
        tt:= NextTime(hypch%,Cursor(2)-BinSize());
        if tt>Cursor(2) or tt<0 then
            MemSetItem(hypch%,0,Cursor(2),c%[],null[]); ' add a terminator if necessary
        endif;          
    endif;
    CursorDelete(-1);                                   ' delete cursors when we finish
    if (XHigh()-XLow())< 2*epdur then                   ' auto-advance if viewing 1 epoch at a time
        Yield(0.2);
        if dirflg%=0 then
            XRange(XLow()+epdur);
        else
            XRange(XLow()-epdur);
        endif;
    endif;
endif;
return 1;
end;

'event_type = 0 signifies regular event, 1 movement event. Variable selected_channel% defines the regular or movement event channel in question.
func EvUp%(vh%,chan%,x,y,flags%, event_type%, selected_channel%)                        ' Event markers are added when you release the left mouse button while Ctrl is depressed
var lastt,nextt,lastcc%[4],nextcc%[4],term%[4],current_tlast,current_eventflag%;
var ok%;
var current_label$; 

'Determine whether the currently processed event is a regular event or a movement event, and set the variables accordingly.
if event_type% = 0 then
    current_tlast := tlast;
    current_eventflag% := evtflg%;
    codes%[0]:=btnnr%-nstates%-2; 
    current_label$ := evlbl2$[codes%[0]-1];
else
    current_tlast := movement_tlast;
    current_eventflag% := mvmflg%;
    codes%[0]:=btnnr%-evtypes% - nstates%-2;
    current_label$ := movement_labels$[codes%[0]-1];  
endif


if ViewKind(vh%)<> 0 then return 1; endif;
lastt:=LastTime(selected_channel%,x,lastcc%[]);                    ' find out what went before and what comes after
nextt:=NextTime(selected_channel%,x,nextcc%[]);

if  flags%=8 then                                       ' Ctrl+ click on a time view to add events
    View(vh%);
    if btnnr%<1 then return 1; endif;                   ' no bEvent button pressed

    docase

        case current_eventflag%=1 and x<=current_tlast then                    ' user tried to put terminator before start of the event
            MemDeleteTime(selected_channel%,3,tlast-BinSize(),current_tlast+BinSize()); ' if user didn-t terminate the current event properly then delete it. (Include possible terminator just before)
            current_tlast:=-1;                                      ' reset event start time
            current_eventflag%:=0;                                     ' and event flag
            
        case current_eventflag%=1 and lastcc%[0]>0 and x>current_tlast then    ' add terminator if end of event selected, pointer is after start of Event
            MemDeleteTime(selected_channel%,3,current_tlast+BinSize(),x);      ' delete all previous events in the time range
            MemSetItem(selected_channel%,0,x,term%[]);                 ' mark end of event
            if nextt>=0 and nextcc%[0]=0 then               ' if next event is a terminator then delete it      (modified for v8 compatibility: Nov 2013)
                MemDeleteTime(selected_channel%,0,nextt);
            endif;
            current_eventflag%:=0;
            current_tlast:=-1;
            
        case current_eventflag%=1 and x>current_tlast and lastcc%[0]>0 then    ' adding a terminator inside an existing event
            MemDeleteTime(selected_channel%,0,current_tlast);                  ' delete previous terminator
            MemSetItem(selected_channel%,0,x,term%[]);
            current_eventflag%:=0;
            current_tlast:=-1;
            
        case current_eventflag%=1 and lastcc%[0]=0 then                ' adding a terminator after another terminator. We must have jumped over an existing Event
            MemSetItem(selected_channel%,0,NextTime(selected_channel%,current_tlast)-BinSize(),term%[]); ' terminate event that was started
            current_eventflag%:=0;
            current_tlast:=-1;
            ' starting an Event 
        case current_eventflag%=0 and (lastt < 0 or lastcc%[0]=0) and (nextt<0 or nextcc%[0]> 0 ) then ' first event in file  OR previous event was a terminator. Next marker if any is an Event mkr
            ' ie, Event start NOT inside an existing event
            ok%:=MemSetItem(selected_channel%,0,x,codes%[],current_label$);		
            current_tlast:=x;                                       ' remember where we put this marker  We might have to delete it later!
            current_eventflag%:=1;
          
        case current_eventflag%=0 and lastcc%[0]>0 and lastcc%[0]<> codes%[0] then ' last marker is event and current marker is a different event
            MemSetItem(selected_channel%,0,x-Binsize(),term%[]);       ' insert a terminator before the new event    
            MemSetItem(selected_channel%,0,x,codes%[],current_label$); 
            MemDeleteTime(selected_channel%,2,x+BinSize(),MaxTime());  ' delete terminator after new event
            current_tlast:=x;                                       ' remember where we put this marker  We might have to delete it later!
            current_eventflag%:=1;   
    endcase;
    
    'Set the bookkeeping variables corresponding to the event type.
    if event_type% = 0 then
        tlast := current_tlast;
        evtflg% := current_eventflag%;
    else
        movement_tlast := current_tlast;
        mvmflg% := current_eventflag%;    
    endif
    
endif;     
CursorVisible(1,0);
return 1;
end;


func MarkEventsDlg%();
var newch%,i%:=0,btnlabel$,tst$;

View(timevh%);
while i% <=9 do
    if evlbl2$[i%] <> "" then
        btnlabel$+=evlbl2$[i%]+"|";                     ' pack the current button labels into a string
    endif;
    i%+=1;
wend;
tst$:=ChanComment$(evtch%);
if tst$ = "" or tst$ = "No comment" or tst$ = btnlabel$ then
    ChanComment$(evtch%,btnlabel$);                     ' store button labels
else
    Message("Warning|The Event buttons have been changed from those used to analyse this file.\n"+
    "Please go back to Set up dialog and choose the button set stored in the channel comment of the Events channel.\n"+
    "Alternatively, you can create a NEW Events channel for these events.");
    return 1;
endif;

CursorDelete(-1);
if ChanKind(evtch%)=8 and InStr(Chan$(evtch%),"m")=0 then ' if Evt chan is a disk-based channel 
    newch%:=MemChan(0,evtch%);                          ' copy to an editable channel
    MemImport(newch%,evtch%,0.0,MaxTime());             ' import events
    ChanDelete(evtch%);                                 ' delete permanent channel
    evtch%:=newch%;                                     ' re-assign channel number variable
endif;

DrawMode(evtch%,15,2);                                  ' mark epochs as states with comment visible
ChanOrder(ssch%,-1,evtch%);                             ' position next to stages channel
ChanShow(evtch%);
return 1;
end;

func CommentEv%();                                      ' add comment to sleep stage
var dum$;

View(timevh%);
if CursorExists(1)=0 or Cursor(1) <XLow() or Cursor(1)>XHigh() then
    CursorSet(1);                                       ' create/fetch cursor if necessary
endif;

DlgCreate("Add Comment to an Event",0,0,44);
DlgAllow(511,CmtEvIdl%);
DlgText("Comment",1,1);
DlgString(1,30,30);
DlgText("Drag cursor into the target Event.",2,2);
DlgText("Press Ctrl+1 to Fetch the cursor",2,3);
DlgButton(0,"");                                        ' No <Cancel> button
DlgButton(1,"Close");
DlgButton(2,"Add Comment (F2)|0x71|Hotkey: <F2>",AddEvCmt%);
DlgShow(dum$);
return 1;
end;

func CmtEvIdl%()
var c$,l$,r$;

View(timevh%);
LastTime(evtch%,Cursor(1)+tick,codes%[],c$);            ' get comment at cursor position
if c$<>lastc$ then
    CommentSplit(c$,l$,r$);
    DlgValue$(1,r$);
    lastc$:=c$;
endif;
return 1;
end;

func AddEvCmt%()
var t,c$,l$,r$;

View(timevh%);
t:=LastTime(evtch%,Cursor(1)+tick,codes%[],c$);         ' get code and comment from the current epoch
if codes%[0]=0 then
    NewsFlash("Cursor is not inside an Event",0,0,0,1);
    return 1;
endif;
CommentSplit(c$,l$,r$);
MarkEdit(evtch%,t,codes%[],Print$("%s %s",l$,DlgValue$(1))); ' reassembel stage label and new comment
return 1;
end;

func Idle1%();                                          ' enable/disable buttons

if ViewKind(timevh%)= 0 then                            ' time view exists
    ToolbarEnable(swsetup%,on%);
    ToolbarEnable(swnew%,on%);
else
    ToolbarEnable(all%,off%);                           ' no time view (new and quite btns only
    ToolbarEnable(swquit%,on%);
    ToolbarEnable(swnew%,on%);     
endif;
return 1;
end;

func Quit%();
var chlst%[101];

if ViewKind(timevh%) = 0 then                           ' if time view exists
    View(timevh%);
    
    if ChanKind(ssch%)=8 then                           ' Count Sleep stages and delete channel if empty
        var dch%,nss%;
        dch%:=ChanDuplicate(ssch%);
        MarkMask(dch%, 0);                              ' set mode 0
        MarkMask(dch%,-1, 1,-1);                        ' include everything (reset)
        MarkMask(dch%, 0, 0, -1);                       ' exclude everything in layer 0
        MarkMask(dch%, 0, 1,0,1,2,3,4,5,6);             ' except sleep state onsets
        nss%:=Count(dch%,0,MaxTime());
        if nss%=0 then
            ChanDelete(ssch%);                          ' empty channel
        else
            ChanDelete(dch%);                           ' found sleep states so just delete the duplicate
        endif;                                          ' no point is saving an empty sleep stage channel
    endif;    
    PSClose();                                          ' close power spectrum, -if there was one...
    View(LogHandle());
    EditSelectAll();
    EditClear();
    Windowtitle$("Log");
    WindowVisible(2);                                   ' iconise
endif;
ProfileSet();

dlgx$:=Print$("%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f",dxp[0],dxp[1],dxp[2],dxp[3],dxp[4],dxp[5],dxp[6],dxp[7],dxp[8]);
dlgy$:=Print$("%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f",dyp[0],dyp[1],dyp[2],dyp[3],dyp[4],dyp[5],dyp[6],dyp[7],dyp[8]);
Profile(key$,"Dlgxpos",dlgx$);
Profile(key$,"Dlgypos",dlgy$);                          ' read stored dialog coordinates from Profile
return 0;
end;

func NewFile%();                                        ' browse to a new datafile
var list%[2],yesno%,ret%:=1;
if ViewKind(timevh%) = 0 then                           ' if current view is a time view
    View(timevh%);
    ChanList(list%[],4096+16384+2097152);               ' check for unsaved buffers
    if list%[0] > 0 then
        yesno%:=Query("The current file contains memory buffers that will be deleted if you proceed.\n"+
        "Press Cancel go back and save them or Proceed to discard them and close the file.","&Proceed","Cancel");
        if yesno% = 0 then
            return 1;                                   ' cancelled. Return to toolbar
        endif;
    endif;
    FileClose(0,-1);                                    ' Proceed: close file and open a new one
	PSClose();                                          ' close power spectrum if it exists
endif;
timevh%:=FileOpen("",0,2);
if timevh% > 0 then
    title$:=WindowTitle$();
    FileSetup();
    ret%:=ChanCount%();
else                                                    ' cancel pressed
endif;
return ret%;
end;

proc FileSetup();                                       ' set standard format for  new datafile
title$:=WindowTitle$();
ChanSelect(-1,0);                                       ' unselect channels
FrontView(timevh%);                                     ' show time view
return;
end;

func StagesDlg%();

var btnlabel$,tst$;
var i%:=0;

View(timevh%);
while  i% <= 6 do
    if slab$[i%] <> "" then
        btnlabel$+=slab$[i%]+"|";                       ' pack the current button labels into a string
    endif;
    i%+=1;
wend;
tst$:=ChanComment$(ssch%);
if tst$ = "" or tst$ = "No comment" or tst$ = btnlabel$ then
    ChanComment$(ssch%,btnlabel$);                      ' store button labels
    redostagesflg%:=0;
else                                                    ' from those used to analyse this file
    Message("Warning|The stage buttons have been changed.\n"+
    "Please go back to SET UP and choose the button set stored in the channel comment\n of the epochs channel."+
    " Alternatively, you can create a NEW sleep state channel.");
    redostagesflg%:=1;
    return 1;
endif;
PSClose();
if PSonoff% then
    View(timevh%);
    Window(0,0,100,55);                                 ' make space for power spectrum
    DoPS();                                             ' create new power spectrum
    PSWindowCopy();                                     ' copy of power spectrum with bands in different colours
endif;
'====
var lst%[2],t;                                          ' create a memory buffer version of any pre-existing hypnogram channel on disk
View(timevh%);
FChanList%(lst%[],64+2048,Print$("Hyp %d",ssch%),0);    ' do we already have a visible hypnogram channel?
if hypchk% or lst%[0]>0 then                            ' we have a visible hypnogram channel or we want one
    var lvl[1];
    hypch%:=MemChan(7,4);                               ' create new realmark buffer for stages
    DrawMode(hypch%,16);                                ' skyline mode
    if lst%[0]>0 then ChanDelete(lst%[1]);  endif;      ' delete existing hypnogram
    
    if InStr(Chan$(ssch%),"m")=0 then                   ' if ssCh is a disk-based channel  (so it might have stages already defined)
        ' redo the hypnogram as a memory buffer 
        MarkMask(ssch%,0,1,-1);                         ' show all markers
        t:=-1;          
        repeat
            t:=NextTime(ssch%,t,codes%[]);              ' create updated hypnogram memory buffer
            if t >-1 then
                if codes%[0]=8 then                     ' set uncoded epochs < 0
                    lvl[0]:=-0.2;
                else
                    lvl[0]:=codes%[0];
                endif;
                MemSetItem(hypch%,0,t,codes%[],lvl[]);  ' copy marker codes to realmark
            endif;
        until t < 0;                   
    endif;
    ChanTitle$(hypch%,Print$("Hyp %d",ssch%));
    YRange(hypch%,0,6.2);
    ChanShow(hypch%);
    ChanOrder(ssch%,-1,hypch%);                         ' next to state marker channel
endif;
'=====
MarkEventsDlg%();

UseMouse%();
return 1;
end;

proc PSClose()                                          ' close pre-existing power spectrum
var vh%[2];
vh%[0]:=psvh%; vh%[1]:=ps2vh%;
for i%:= 0 to 1 do
    if ViewKind(vh%[i%]) = 4 then                       ' close any previous power spectrum
        View(vh%[i%]);
        FileClose(0,-1);                                ' close it , no query
    endif;
next;
return;
end;

proc DoPS()                                             ' create power spectrum
var lst%[2],ok%;

if PSchan%=-3 then
    ChanList(lst%[],1+65536);                           ' check whether the source waveforms are still selected
    if lst%[0]=0 then                                   ' force user to re-select them or Abort
        Message("Error|Cannot create power spectra.No waveform channels selected.\n"+
        "Click on channel numbers of one or more waveforms to select them.");
        repeat
            ok%:=Interact("Select waveform channels for power spectra (Click on channel numbers).",511,0,"OK|0x0d|Hotkey: <Enter>","Abort||Abandon the analysis");
            if ok%=1 then
                ChanList(lst%[],1+65536);               ' have waveforms been selected?
                if lst%[0]=0 then ok%:=0; endif;
            endif;
        until ok%>=1;
        if ok%=2 then halt; endif;                      ' user pressed <Abort>
    endif;
endif;

psvh%:=SetPower(pschan%,fftnrarr%[fftszndx%],fftwinndx%);
View(LogHandle());                                      ' clear and size the log window
WindowTitle$("% Power in bands");
EditSelectAll();
EditClear();
Window(0,55,55,100);
WindowVisible(2);                                       ' keep iconised for now
return;
end;

proc PSWindowCopy();                                    ' copy of power spectra for coloured power bands 
var nch%,nbins%,binsz,yU$,list%[2],inc,ttl$:= " power in bands";
var ch%,group%,destch%,i%,j%;

View(psvh%);
binsz:=BinSize();
nbins%:=Len([]);
if powpctchk% then
    ttl$:="per cent"+ttl$;
    yU$:="%";
else
    yU$:=ChanUnits$(1);
endif;
nch%:=ChanList(list%,1);                                ' number of power spectra
ps2vh%:=SetResult(4*nch%,nbins%, binsz, 0, ttl$, "Hz",yU$); ' make copy of power spectrum
ch%:=1;
for j%:= 1 to nch% do
    for i%:= 1 to 4 do
        ChanTitle$(ch%,View(psvh%).ChanTitle$(j%));
        ChanComment$(ch%,View(psvh%).ChanComment$(j%));
        ch%+=1;          
    next;
next;     
XRange(edgeHz[0]-bwHz,edgeHz[4]+bwHz);
CursorSet(5,edgebin%[0],edgebin%[1],edgebin%[2],edgebin%[3],edgebin%[4]);
CursorLabel(4,-1,"%2.1pHz");
for i%:=1 to 5 do
    CursorlabelPos(i%,inc);                             ' cascade cursor labels
    inc+=3;
next;

destch%:=1;
for group%:=1 to nch% do                                ' overlay channels in groups of 4 to display bands in different colours
    ChanColour(destch%,2,col%[0]);
    for ch%:=1 to 3 do
        ChanOrder(destch%,0,destch%+ch%);
        ChanColour(destch%+ch%,2,col%[ch%]);
    next;
    YAxisLock(destch%,1,0);
    Optimise(destch%);
    destch%+=4;
next;
ChanNumbers(0);                                         ' hide channel numbers to discourage ungrouping of channels
Window(55,55,100,100);
return;
end;

proc DoPSProcess()                                      ' process current epoch into power spectrum
var n%,etim,ttl$,list%[2],nch%,pc;
var bwidth%[4],ch%,g%,group%,bnd%,bwtot%;

if evpos < 0 then evpos:=0.0; endif;                    ' Process will crash is start value < 0
etim:=evpos+epdur;
if etim > MaxTime() then
    NewsFlash("No epoch found",1.5,0,0,0);              ' trap possibility that cursor 1 is at the end of the file
    return;
endif;
View(psvh%);
nch%:=ChanList(list%[],1);
var Yhi[nch%],ptot[nch%];
for ch%:=0 to 3 do
    bwidth%[ch%]:=hibin%[ch%]-lobin%[ch%];              ' number of bins in each band
next;
bwtot%:=ArrSum(bwidth%[]);                              ' number of bins in banded range
Process(evpos,etim,1);                                  ' process current epoch, clear first
Optimise(-1,edgebin[0],edgebin[4]);
'Optimise(-1,edgebin[0]+1,edgebin[4]);	               'optimise displayed range excluding artifact due to offset
for i%:=1 to nch% do
    Yhi[i%-1]:=YHigh(i%);
    ptot[i%-1]:=ArrSum(View(psvh%,i%).[lobin%[0]+1:bwtot%]); ' total power in banded range
next;
n%:=Sweeps();
View(ps2vh%);

g%:=1;
for group%:=1 to nch% do                                ' copy bands into separate channels of the copy
    for bnd%:=0 to 3 do
        ch%:=bnd%+g%;
        ArrConst(View(ps2vh%,ch%).[lobin%[bnd%]+1:bwidth%[bnd%]],View(psvh%,group%).[lobin%[bnd%]+1:bwidth%[bnd%]]);
        if powpctchk% then
            pc:=100.0/ptot[group%-1];                   ' conversion factor to %total power
            ArrMul(View(ps2vh%,ch%).[lobin%[bnd%]+1:bwidth%[bnd%]],pc); ' convert to % total power
            Yrange(ch%,0.0,yhi[group%-1]*pc);           ' convert range to percent
        else
            YRange(ch%,0.0,yhi[group%-1]);
        endif;
    next;
    g%+=4;                                              ' next group of bands
next;
View(ps2vh%);
ttl$:="Epoch: "+Print$("%5.1f",evpos)+" - "+Print$("%5.1f",etim)+"s"+".  Nr. sweeps: "+Str$(n%);
XTitle$(ttl$);
WindowVisible(1);
PowerinBands(evpos,etim,ttl$);
return;
end;

proc PowerInBands(st,et,ttl$);                          ' calculate power in bands
var nch%,list%[2],i%,j%;
View(psvh%);
nch%:=ChanList(list%[],1);                              ' how many channels?
var buffer[edgebin%[4]+1];                              ' array to hold a copy of relevant part of power spectrum
var chlist%[nch%+1];                                    ' size array for channels
var pwrband[4][nch%];                                   ' 2-d array to hold 4 power values per channel
var units$[nch%];
var ptot[nch%];
ChanList(chlist%[],1);                                  ' store list of channels
for i%:= 1 to chlist%[0] do
    units$[i%-1]:=ChanUnits$(i%);                       ' store units for the printout
    ArrConst(buffer[],View(psvh%,chlist%[i%]).[]);      ' copy a channel
    ArrIntgl(buffer[]);                                 ' integrate buffer
    Ptot[i%-1]:=buffer[hibin%[3]]-buffer[lobin%[0]];    ' total power in all bands
    if ptot[i%-1] > 0 then                              ' trap divide by zero error if no data in power spectrum
        for j%:= 0 to 3 do
            pwrband[j%][i%-1]:= (buffer[hibin%[j%]]-buffer[lobin%[j%]]); ' power in this band
            if powpctchk% = 1 then
                pwrband[j%][i%-1]*=(100.0/ptot[i%-1]);  ' convert to % total power in band
            endif;
        next;
    endif;
next;
View(LogHandle());
EditSelectAll();
EditClear();
View(psvh%);                                            ' allows access to channel titles below
Printlog("%s\n\n",ttl$);
var format$;                                            ' format specifier for printing power values
if powpctchk% = 1 then
    Printlog("per cent of total power in each band\n");
    format$:="%d %s\t%4.2f\t%4.2f\t%4.2f\t%4.2f\t%.3g\t(%s)\n";
else
    Printlog("Power in each band\n");
    format$:= "%d %s\t%.3g\t%.3g\t%.3g\t%.3g\t%.3g\t(%s)\n";
endif;
Printlog("Delta:  %3.2f - %3.2fHz   Theta:  %3.2f - %3.2fHz\nAlpha:  %3.2f - %3.2fHz   Beta  %3.2f - %3.2fHz\n\n",edgeHz[0],edgeHz[1],edgeHz[1],edgeHz[2],edgeHz[2],edgeHz[3],edgeHz[3],edgeHz[4]);
PrintLog("Bands:\tDelta\tTheta\tAlpha\tBeta\tTotal power\nChan.\n");
for i%:=1 to nch% do
    Printlog(format$,i%,ChanTitle$(i%),pwrband[0][i%-1],pwrband[1][i%-1],pwrband[2][i%-1],pwrband[3][i%-1],ptot[i%-1],units$[i%-1]);
next;
Printlog("\n");
View(LogHandle()).WindowVisible(1);
FrontView(timevh%);                                     ' move focus away from log to prevent uninentional text entry
return;
end;

func IdlReptDlg%()
LinkCsrToDlg(c1itm%,1,timevh%);                         ' link cursors 1 and 2 in source file to the dialog
LinkCsrToDlg(c2itm%,2,timevh%);
if Cursor(1)>Cursor(2) then
    CursorRenumber();
endif;
return 1;
end;

func ChReptDlg%(item%);                                 ' respond to changes in the report set up dialog
var t1,t2,chan%,i%,en%;

if item% = 0 or item% = 1 then
    chan%:= DlgValue(1);                                ' currently selected epoch channel
    MarkMask(chan%,0,1,-1);                             ' show all markers in layer 00
    MarkMask(chan%,0,0,8);                              ' hide marker 8 (unstaged)
    t1:=NextTime(chan%,-1);
    t2:=LastTime(chan%,MaxTime()+1)+epdur;
    MarkMask(chan%,-1, 1,-1);                           ' reset epoch channel to show all
    if t1 < 0 or t2 < 0 then                            ' no marked stages in this channel
        t1:=0.0; t2:=MaxTime();
    endif;
    DlgValue(3,t1);                                     ' set appropriate time range 
    DlgValue(4,t2);
endif;
if item%=0 or item%=2 then
    if Instr(ChanTitle$(DlgValue(2)),"Evt")=0 then      ' uncheck and disable "events" checkbox if no valid "events" channel
        DlgValue(5,0);
        DlgEnable(0,5);
    else
        DlgEnable(1,5);
    endif;
endif;

for i%:=5 to 12 do                                      ' disable <OK> if all check boxes were un-checked
    if DlgValue(i%)> 0 then en%:=1; break; endif;
next;
DlgEnable(en%,-1);
if dlgValue(9)=0 then
    DlgValue(10,0); DlgEnable(0,10);                    ' disable include events if epoch by epoch is off
else
    DlgEnable(1,10);
endif;

LinkDlgToCsr%(item%,c1itm%,1,timevh%);                  ' link times in dialog to cursor in source file
LinkDlgToCsr%(item%,c2itm%,2,timevh%);
CursorRenumber();
return 1;
end;

proc LabelEdit(input$,&array$[]);                       ' remove unwanted characters from the stage labels before printing
var i%:=0,L%,n%;
L%:=Len(array$[]);
repeat 
    n%:= Instr(input$,"|");
    if n% > 0 then
        array$[i%]:=Left$(input$,n%-1);
        input$:=DelStr$(input$,1,n%);
        i%+=1;
    endif;
until n% = 0 or i% > L%-1;	
return;
end;

proc CommentSplit(in$,&out1$,&out2$);                   ' split string into two parts. Separator is the first space character.
var ndx%,L%;
L%:=Len(in$);
ndx%:=Instr(in$," ",2);                                 ' find first space (ignoring leading space)
if ndx% > 0 then
    out1$:=Left$(in$,ndx%);
    out2$:=Right$(in$,L%-ndx%);
else
    out1$:=in$;
    out2$:="";
endif;
return;
end;

func AllOn%()
var i%;

for i%:=5 to 12 do
    DlgValue(i%,1);
next;
DlgEnable(1,-1,10);                                     ' enable <OK> if no check boxes enabled
return 1;
end;

func AllOff%()
var i%;

for i%:=5 to 12 do
    DlgValue(i%,0);
next;
DlgEnable(0,-1,10);                                     ' disable <OK> if no check boxes enabled
return 1;
end;

func Report%();
var sbgn,snd,sdur;                                      ' times of first and last stage assigned and duration analysed
var ok%,h%,m%,s%;
var stime,etime,nep%,n%;
var chlst%[101];

View(timevh%);
tick:=BinSize();                                        ' get minimum time unit for time view
if ChanKind(ssch%) <> 8 then
    ChanList(chlst%[],32+2048+16384);
    if chlst%[0]=0 then
        NewsFlash("No suitable stages channel found",1.5,45,10,1);
        return 1;
    else
        ssch%:=chlst%[1];
    endif;
endif;

View(LogHandle());                                      ' clear the log
WindowTitle$(title$+" report");
EditSelectAll();
EditClear();
WindowVisible(2);                                       ' clear log and iconise

View(timevh%);
if CursorExists(1)=0 or CursorExists(2)=0 then
    CursorSet(2);
else
    CursorRenumber();
endif;
var lst%[2],evtchk%;
FChanList%(lst%[],32,"Evt",0);                          ' get list of candidate Event channels
if lst%[0]>0 then
    evtch%:=lst%[1];                                    ' set most likely event channel as default
    evtchk%:=1;                                         ' default to report events    
endif;

dd%:=4;
DlgCreate("Report Set-Up",dxp[dd%],dyp[dd%],70);
DlgAllow(511,IdlReptDlg%,ChReptdlg%);                   ' allow cursor dragging
DlgChan(1,"Epoch channel",32+2048+16384);
DlgChan(2,"Event channel",32+2048+16384);               ' exclude 'none	+131072'

c1itm%:=3; c2itm%:=4;
DlgGroup("Time range",1,3.3,67,3.9);
DlgText("Start time (s)",2,4.2);
DlgText("End time (s)",2,5.2);
DlgReal(3,16,0,MaxTime(),-3,4.2,1);
DlgReal(4,16,0,MaxTime(),-3,5.2,1);
DlgText("TIP:    Drag vertical cursors to adjust the time range.",20,6.3);

DlgButton(2,"   Zero   ",C1Zero%,20,4.2);
DlgButton(3,"Fetch Csr1",FetchCsr1%,33,4.2);
DlgButton(4,"MaxTime",C2MaxT%,20,5.2);
DlgButton(5,"Fetch Csr2",FetchCsr2%,33,5.2);

DlgGroup("Scope of Report",6,8,57,5);
DlgCheck(5,"Summary of Events",8,8.9);
DlgCheck(6,"Summary of sleep stages",8,9.9);
DlgCheck(7,"Sequence of Sleep states",8,10.9);
DlgCheck(8,"Sequence of Events",8,11.9);
DlgCheck(9,"Epoch by Epoch times",38,8.9);
DlgCheck(10,"include Event times",38,9.9);
DlgCheck(11,"Power in bands",38,10.9);
DlgCheck(12,"% total power in bands",38,11.9);
DlgButton(6,"All On",AllOn%);
DlgButton(7,"All Off",AllOff%);

DlgButton(1,"OK|0x0d",MyOK%);
DlgButton(0,"Cancel",MyCancel%);
ok%:=DlgShow(ssch%,evtch%,stime,etime,reptchk%[]);      ' evtchk%,scope%)
if ok% <=0 then return 1; endif;

'REPORT OVERVIEW
MarkMask(ssch%,0,1,-1);                                 ' show all markers in layer 00
MarkMask(ssch%,0,0,8);                                  ' hide marker 8 (blank)
n%:=Count(ssch%,0.0,MaxTime());                         ' count marked stages
sbgn:=NextTime(ssch%,-1);
snd:=LastTime(ssch%,MaxTime()+1);
sdur:=snd+epdur-sbgn;                                   ' time from onset of first  to end of the last marked stages
MarkMask(ssch%,0,1,-1);                                 ' show all markers in layer 00
if n% = 0 then                                          ' no marked stages
    NewsFlash("No marked stages in selected epoch channel",1.5,0,0,1); ' give up if no marked stages
    return 1;
endif;
var label$[nstates%+1];
LabelEdit(ChanComment$(ssch%),label$[]);                ' get stage labels from the channel comment
Printlog("File:\t%s\n",WindowTitle$());
Printlog("Recorded:\t%s\n",FileDate$(2,2,3,1,"/"));
Printlog("Start time:\t%s\n",FileTime$(1,15,0,":"));
HrMinSec(Round(MaxTime()),h%,m%,s%);                    ' get file duration in clock format
Printlog("Duration :\t%ds\t%dhr %dmin %ds\n",Round(MaxTime()),h%,m%,s%);
sdur:=Round(sdur);                                      ' round up to nearest second
HrMinSec(sdur,h%,m%,s%);                                ' get file duration in clock format
Printlog("Staged duration:\t%ds\t(%dhr %dmin %ds)\n\n",sdur,h%,m%,s%);
Printlog("Selected range:\t%5.2f to %5.2fs\n",stime,etime);
var st,nd;
st:= NextTime(ssch%,stime-tick);                        ' start and end to nearest epoch
nd:=NextTime(ssch%,etime);
if nd =-1 then
    nd:=LastTime(ssch%,MaxTime()+1);                    ' cope if we hit the end of the file
endif;
Printlog("Tabulated range:\t%5.2f to %5.2fs\n",st,nd);
nep%:=Count(ssch%,stime,etime-0.01);                    ' count epochs of each type (don-t count terminating marker)
Printlog("Epoch count:\t %d \n",nep%);
Printlog("Epoch duration:\t %ds\n\n",epdur);

if reptchk%[0] then                                     ' event channel exists
    Printlog("\nEvents Summary\n");
    for i%:=1 to 9 do
        RptEvtsSummary(evtch%,i%,stime,etime);
    next;
endif;

if reptchk%[1] then
    RptStagesSummary(stime,etime,nep%,label$[]);
endif;

if reptchk%[2] then
    RptSSsequence(stime,etime);
endif;

if reptchk%[3] then
    RptEvtsequence(stime,etime);
endif;

if reptchk%[4] then
    RptStages(stime,nep%,reptchk%[5]);                  ' stage by stage printout(possibly including events)
endif;

if reptchk%[6] or reptchk%[7] then                      ' print banded power output
    var nn%,list%[2],nsel%;
    nn%:=ChanList(list%[],512+2048);                    ' list of visible realwave channels
    if nn%=0 then                                       ' no trend plots found . Create them now from selected waveforms
        nsel%:=ChanList(list%[],1+512+65536);           ' list of selected waveforms and realwaves
        if nsel%=0 then
            Interact("Select the source channels for banded power print out (Ctrl+click on channel numbers)",511,0); 
            nsel%:=ChanList(list%[],1+512+65536);       ' list of selected waveforms and realwaves
        endif;
        if nsel%>0 then
            DoTrendplots%();                            ' create the power trend plots so that results can be tabulated
        endif;
    endif;
endif;

if reptchk%[6] then
    RptPiB(stime,etime,"",0,512+2048+4096+16384);       ' print power in bands(visible Realwave Virtuals)
endif;

if reptchk%[7] then
    ToolbarText("  Please be patient. This will take a while...");
    Percentpower%();   
    RptPiB(stime,etime,"Percent ",1,512+1024+4096+2097152); ' print percent total power in bands (hidden realwave mem buffers)
    ToolbarText(" Sleep staging script.");
endif;    

if nsel%>0 then                                     ' delete power trend plots after tabulation
    var i%;
    View(timevh%);
    for i%:=0 to 4 do
        FChanList%(chlst%[],512+2048,ttl$[i%],0);   ' delete unwanted visible trend channels
        ChanDelete(chlst%[]);
    next;          
endif;     

View(LogHandle());
MoveTo(0,0);                                            ' top of file
Window(0,0,100,100);                                    ' fullscreen
FrontView(LogHandle());
WindowVisible(1);                                       ' show report
return 1;
end;

proc RptSSsequence(st,et)                               ' tabulate sequence of sleep states (Hypnogram)
var t,codes%[4],s$,clast%,dur,ton,toff;
var nep%,hr%,lasthr%,cr$;

View(timevh%);
Printlog("\nSequence of Sleep states\nState\tStart (s)\tEnd (s)\tDuration (s)\tEpochs\n");
View(timevh%);
MarkMask(ssch%, 0);                                     ' set mode 0
MarkMask(ssch%,-1, 1,-1);                               ' include everything (reset)
MarkMask(ssch%, 0, 0, 8);                               ' exclude code 8 in layer 0 (terminators)
t:=st-Binsize();
t:=NextTime(ssch%,t,codes%[],s$);                       ' first in time range
Printlog(" %s\t%.1f",s$,t);
clast%:=codes%[0];
repeat 
    t:=NextTime(ssch%,t,codes%[],s$);
    nep%+=1;
    if codes%[0]<>clast% then                           ' reached the end of an episode/start of a new on
        toff:=t;
        dur:=toff-ton;
        
        hr%:=(t-st)/3600;
        if hr%>lasthr% then
            cr$:="\n";                                  ' insert empty line when an hour boundary has been crossed
            lasthr%:=hr%;
        else
            cr$:="";
        endif;        
        
        Printlog("\t%.1f\t%.1f\t%3d\n%s %s\t%.1f",toff,dur,nep%,cr$,s$,toff); ' print type and on/off/duration (space at 1 hr intervals)
        clast%:=codes%[0];
        ton:=toff;
        nep%:=0;
    endif;
until t>et or t<0;
if t>et or t<0 then                                     ' insert end of the episode that was in progress at end time
    MarkMask(ssch%,0,0,clast%);
    if t<0 then t:=MaxTime();
    else
        t:=NextTime(ssch%,t);
    endif;
    nep%:=(t-ton+1)/epdur;
    Printlog("\t%.1f\t%.1f\t%3d\n\n",t,t-ton,nep%);
endif;
MarkMask(ssch%,-1, 1,-1);                               ' include everything (reset)
end;

proc RptEvtsequence(st,et)
var t1,t2,codes%[4],e$,nev%,dch%;
var hr%,lasthr%;

View(timevh%);
Printlog("\nSequence of Events\n  #\tType\tStart (s)\tEnd (s)\tDuration (s)\n");
View(timevh%);
dch%:=ChanDuplicate(evtch%);                            ' make a copy
MarkMask(evtch%, 0);                                    ' set mode 0
MarkMask(evtch%,-1, 1,-1);                              ' include everything (reset)
MarkMask(evtch%,0,0,0);                                 ' exclude code zero in layer zero (event terminators)

MarkMask(dch%,0);                                       ' set mode 0
MarkMask(dch%,-1, 1,-1);                                ' include everything (reset)
MarkMask(dch%,-0, 0,-1);                                ' exclude everything in layer zero
MarkMask(dch%,0,1,0);                                   ' include code zeroes only in layer 0 (event terminators)
t1:=st-Binsize();
repeat
    t1:=NextTime(evtch%,t1,codes%[],e$);                ' start of event
    if t1<0 or t1>et then break; endif;                 ' next event is after end time or does not exist
    t2:=NextTime(dch%,t1) ;                             ' end of event
    if t2<0 then t2:=MaxTime(); endif;                  ' event end after end time or we hit end of file
    nev%+=1;    
    PrintLog("%3d\t%s\t%.2f\t%.2f\t%.2f\n",nev%,e$,t1,t2,t2-t1);
    hr%:=(t1-st)/3600;
    if hr%>lasthr% then
        Printlog("\n");                                 ' insert empty line when an hour boundary has been crossed
        lasthr%:=hr%;
    endif;
    t1:=t2;
until t1=MaxTime();
ChanDelete(dch%);
MarkMask(evtch%,-1, 1,-1);                              ' include everything (reset)
end;

func Percentpower%()                                    ' create percent power as virtual channels so we can include in report using Export chanlist()
var i%,j%,chlst%[11],alst%[2],expr$,srch$,newch%;

View(timevh%);
ChanList(chlst%[],1+65536);                             ' selected waveform chans
if chlst%[0]=0 then                                     ' if none selected then pschan% holds single waveform channel to process
    chlst%[0]:=1;
    chlst%[1]:=pschan%;    
endif;

var pbch%[chlst%[0]][5];                                ' 2d array to hold virtual power in band data for 5 bands of each selected waveform channel
var pcpwch%[chlst%[0]][4];                              ' array to hold % total power derived from the above power in band channels

for j%:=1 to chlst%[0] do
    for i%:=0 to 4 do
        srch$:=Print$("%s(%d)",ttl$[i%],chlst%[j%]);
        FChanList%(alst%[],512+4096+8192,srch$,0);      ' identify each power in band channel in turn
        pbch%[j%-1][i%]:=alst%[1];                      ' save them to 2-d array
    next;
next;
'create %total power in bands channels
for j%:=1 to chlst%[0] do
    for i%:=0 to 3 do
        expr$:=Print$("ch(%d)*100.0/ch(%d)",pbch%[j%-1][i%],pbch%[j%-1][4]); ' percent total power channels
        pcpwch%[j%-1][i%]:=VirtualChan(0,expr$,0,epdur);
        ChanTitle$(pcpwch%[j%-1][i%],Print$("%s(%d)",ttl$[i%],chlst%[j%]));
        ChanUnits$(pcpwch%[j%-1][i%],"%p.tot");
        DrawMode(pcpwch%[j%-1][i%],16);                 ' skyline 
        Optimise(pcpwch%[j%-1][i%]);
        newch%:=MemChan(0,pcpwch%[j%-1][i%]);
        MemImport(newch%,pcpwch%[j%-1][i%],0,MaxTime());
        ChanDelete(pcpwch%[j%-1][i%]);              'delete virtual version
        pcpwch%[j%-1][i%]:=newch%;
    next;
next;
return 1;
end;

proc RptPiB(st,et,hdr$,del%,types%)                     ' report on power in bands
var list%[2],n%,tstart;
var l%,c%,sz%,t;    

View(timevh%);
n%:=ChanList(list%[],types%);                           ' list of visible realwave channels           512+2048
if n%>0 then                                            ' copy paste channels to the log    
    var blist%[n%+1];
    ChanList(blist%[],types%);
    Printlog("\n\n%sPower in Bands (%s)\n",hdr$,View(timevh%).ChanUnits$(blist%[1]));
    l%:=View(Loghandle()).MoveBy(1);                  ' get line and column number of last line of table
    c%:=View(Loghandle()).MoveBy(2);
    
    ExportChanList(0);                                  ' Initialise the channel list               512+2048
    tstart:=NextTime(ssch%,st)-Binsize();               ' start at an epoch boundary
    ExportChanList(tstart,et,blist%[]);
    ExportRectFormat(1.0/epdur,0,"\"","	",1);
    EditCopy(4);                                  ' needed for correct tabulation    
    View(Loghandle());
    EditPaste();    
    TabSettings(17);                                    ' needed for correct tabulation
    
    ' append sleep scores
    View(timevh%);
    sz%:=Count(ssch%,tStart,et);                        ' number of epochs in range
    var ra$[sz%],code%[4],lbl$;
    t:=tstart;
    for i%:=0 to sz%-1 do
        t:=NextTime(ssch%,t,code%[],lbl$);
        ra$[i%]:=lbl$;                                  ' fill array with sequence of sleep states
    next;
    View(LogHandle());
    MoveTo(0,c%,l%);
    EditFind("$",1,4); 
    View(LogHandle()).Print("\tSTATE");    
    for i%:=0 to sz%-1 do
        EditFind("$",1,4);                            ' find decimal followed by end of line
        View(LogHandle()).Print("\t%s",ra$[i%]);        ' insert sleep stage label NB. Must use Print(). Printlog() always prints to end of file.
    next;
endif;
if del%=1 then                                          ' delete channels after copying
    View(timevh%);
    ChanDelete(blist%[]);
endif;
return;
end;

proc RptStages(st,nep%,evtchk%)                         ' stage by stage report
var n%,j%,t,t2,Tevt,c%[4],comm$;
var c1$,c2$,c3$,c4$,ndT,durn;

View(timevh%);
Printlog("\n\nEpoch by epoch\tT start\tT end\tStage\tComment\t");
if evtchk% > 0 then
    Printlog("nEvts\t Type\tNote\t Onset(s)\tDur.\t Type\tNote\t Onset(s)\t Dur.\tetc.");
endif;
Printlog("\n nr. \t  (s)  \t (s)  \t(s)\n");
if evtchk% > 0 then                                     ' mask all events of type 0 before counting
    MarkMask(evtch%,0,1,-1);                            ' show all markers in layer 00
    MarkMask(evtch%,0,0,0);                             ' hide marker 00
endif;
t:=st-tick;                                             ' make sure we catch the first one
i%:=0;

while i% < nep% do
    i%+=1;
    t:=NextTime(ssch%,t,codes%[],comment$);
    if comment$ = "U " then                             ' no stage
        comment$:=" - ";
        c1$:="U";c2$:="";                               ' added 24/01/2014 (previously table did not mark unstaged episodes correctly)
    else
        CommentSplit(comment$,c1$,c2$);                 ' split comment into two around first space
    endif;
    t2:=t+epdur;
    if evtchk% > 0 then
        n%:=Count(evtch%,t,t2);
        Printlog(" %d\t%.0f\t%.0f\t%s\t%s\t%d\t",i%,t,t2,c1$,c2$,n%);
        if n% > 0 then
            Tevt:=t;
            for j% := 1 to n% do
                Tevt:=NextTime(evtch%,Tevt,c%[],comm$); ' find start of next event
                MarkMask(evtch%,0,1,-1);                ' show all markers (so we can find end of current event
                ndT:=NextTime(evtch%,Tevt);             ' end of event
                durn:=ndT-Tevt;
                CommentSplit(comm$,c3$,c4$);
                Printlog(" %s\t%s\t%.2f\t%.2f\t",c3$,c4$,Tevt,durn);
                MarkMask(evtch%,0,0,0);                 ' hide marker 00 (so we can find start of next event
            next;
        endif;
    else                                                ' no event channel
        Printlog(" %d\t%.0f\t%.0f\t%s\t%s\t",i%,t,t2,c1$,c2$);
    endif;
    Printlog("\n");
wend;
if evtchk% > 0 then
    MarkMask(evtch%, -1, 1, -1);                        ' reset marker filter on events channel
endif;
return;
end;

proc RptStagesSummary(st,et,nep%,label$[]);
var epinstate%,tinstate,pctinstate;
Printlog("\nSleep stages Summary\n  State\tnEpochs\tTime(s)\t%%time \n");
'count number of epochs of each state
MarkMask(ssch%,0);                                      ' set mode 0
MarkMask(ssch%,-1, 1,-1);                               ' include everything in layer 0
for i%:=0 to nstates% do
    MarkMask(ssch%, 0, 0, -1);                          ' exclude everything in layer 0
    MarkMask(ssch%, 0,1,i%);                            ' include one stage
    epinstate%:=Count(ssch%,st,et-0.01);                ' count epochs of this type
    tinstate:=epinstate%*epdur;                         ' time
    pctinstate:=100.0*epinstate%/nep%;                  ' and per cent time
    Printlog("  %s\t %d\t %4.1f \t%4.2f\n",label$[i%],epinstate%,tinstate,pctinstate);
next;
MarkMask(ssch%, 0, 0, -1);                              ' exclude everything in layer 0
MarkMask(ssch%, 0,1,8);                                 ' include code 8 :unstaged epochs
epinstate%:=Count(ssch%,st,et-0.01);                    ' count epochs of this type
tinstate:=epinstate%*epdur;                             ' time
pctinstate:=100.0*epinstate%/nep%;                      ' and per cent time
Printlog("  Unstaged\t %d\t %4.1f \t%4.2f\n",epinstate%,tinstate,pctinstate);
MarkMask(ssch%,-1, 1,-1);                               ' reset epoch channel to show all
return;
end;

func RptEvtsSummary(ch%,code%,st,et)                   
var n%,t1,t2,i%,sum,tpc,mindur,maxdur,mndur,sd;
var copych%;

copych%:=ChanDuplicate(ch%);                            ' filter the duplicate to show end of range markers
MarkMask(copych%, 0);                                   ' set mode 0
MarkMask(copych%,-1, 1,-1);                             ' include everything (reset)
MarkMask(copych%, 0, 0, -1);                            ' exclude everything in layer 0
MarkMask(copych%, 0, 1, 0);                             ' include codes zero (end of state)

MarkMask(ch%, 0);                                       ' set mode 0
MarkMask(ch%,-1, 1,-1);                                 ' include everything (reset)
MarkMask(ch%, 0, 0, -1);                                ' exclude everything in layer 0
MarkMask(ch%, 0, 1, code%);                             ' include code
n%:=Count(ch%,st,et);                                   ' n examples of this state
if n%>0 then
    var on[n%],off[n%],dur[n%];                         ' array to store state durations
    t1:=st-Binsize();                                   ' calculate durations
    for i%:=0 to n%-1 do
        t1:=NextTime(ch%,t1);                           ' next onset
        t2:=NextTime(copych%,t1);                       ' end time of this state
        on[i%]:=t1;
        off[i%]:=t2;
        dur[i%]:=t2-t1;
        t1:=t2;
    next;    
    maxdur:=dur[Max(dur[])];                            ' longest
    mindur:=dur[Min(dur[])];                            ' shortest
    sum:=ArrSum(dur[],mndur,sd);                        ' mn, sd
    tpc:=100.0*sum/(et-st);
    
    Printlog("%s (Code: %d)\n",evlbl2$[code%-1],code%);
    Printlog("  #\tStart (s)\tEnd (s)\tDur. (s)\n");
    for i%:=0 to n%-1 do
        Printlog("%3d\t%6.3f\t%6.3f\t%6.3f\n",i%+1,on[i%],off[i%],dur[i%]);
    next;
    Printlog("\nSummary\nCount\tTotal Dur(s)\t % of time\tShortest(s)\tLongest(s)\tMean(s)\t stdev\n");     
    Printlog("%2d\t%6.3f\t%5.3f\t%6.3f\t%6.3f\t%6.3f\t%6.3f\n",n%,sum,tpc,mindur,maxdur,mndur,sd);
    Printlog("-------------------------------------------------------------------------------------------------\n");
endif;
View(timevh%);
MarkMask(ch%, 0);                                       ' set mode 0
MarkMask(ch%,-1, 1,-1);                                 ' include everything (reset)
ChanDelete(copych%);
return 1;
end;

proc HrMinSec(t,&hr%,&mins%,&s%);                       ' t in sec returned in hr:min:s format
s%:=t mod 60.0;
mins%:=t/60.0;
if mins% > 59 then
    hr%:=mins%/60;
    mins%:=mins% mod 60;
endif;
return;
end;

func Setup%();                                          ' set up calls a dialog for selecting users choice of stage buttons
var ret%,i%;

'------------------------
ret%:=Epochs%();                                        ' epochs dialog and set up
if ret% < 1 then return 1; endif;
'------------------------
'	Stage button selection dialog
if swbtns% then
    if redostagesflg% then chk0%:=0; chk1%:=0; chk2%:=0; chk3%:=0; endif; ' 
    docase
    case option% <2 or option% > 4 then chk0%:=1;       ' convert option% to default checkbox selection
    case option% = 2 then chk1%:=1;
    case option% = 3 then chk2%:=1;
    case option% = 4 then chk3%:=1;
    endcase;
    okk%:=Stagebtnsdlg();	                       
    docase
    case chk0% = 1 then option% := 1;                   ' convert checkbox selection to option
    case chk1% = 1 then option% := 2;
    case chk2% = 1 then option% := 3;
    case chk3% = 1 then option% := 4;
    endcase;
endif;
Selectbtns();
'------------------------ 'Define Event buttons

evtypes%:=0;                                            ' initialise number of buttons to create (Nov 2013)
if evbtns% > 0 then
    okk%:=EvtBtnsDlg();
endif;
EvtbtnSelect();                                         ' set up event toolbar buttons and state labels accordingly
if PSonoff% > 0 then
    PSsetup%();                                         ' power spectrum setup dialog
endif;
if PSonoff% = on% then 
    var edg$[5];                                        ' :={"Edge 5","Edge 4","Edge 3","Edge 2","Edge 1"};  v8.03 and higher
    edg$[0]:="Edge 5"; edg$[1]:="Edge 4"; edg$[2]:="Edge 3"; edg$[3]:="Edge 2"; edg$[4]:="Edge 1"; 
    var b$[4];                                          ' :={"Beta","Alpha","Theta","Delta"};  v8.03 and higher
    b$[0]:="Beta"; b$[1]:="Alpha"; b$[2]:="Theta"; b$[3]:="Delta"; 
    var xp,yp,itm%,stp;
    stp:=Trunc(bwHz*10000.0)/10000.0;                   ' truncate binsize tp 5 dec. places for readability
    
    dd%:=6;
    DlgCreate("Power in Bands",dxp[dd%],dyp[dd%]);
    DlgAllow(511,idlbandsdlg%);
    DlgCheck(1,"Check to show % of total power in bands",2,9);
    DlgText("Un-check for power in bands.",5,9.6);
    DlgCheck(2,"Check for power in band trend plots.",2,10.6);
    DlgGroup("Bands",2,1,36,7.2);
    DlgText("Hz",17,2);
    DlgText("Band",31,2);
    xp:=5; yp:=3;
    for i%:=0 to 4 do
        DlgText(edg$[i%],xp,yp);
        yp+=1;
    next;
    xp:=28; yp:=3.5 ;
    for i%:=0 to 3 do
        DlgText(">",xp,yp);
        yp+=1;    
    next;
    xp:=31; yp:=3.55;
    for i%:=0 to 3 do
        DlgText(b$[i%],xp,yp);
        yp+=1;    
    next;
    
    xp:=15; yp:=7; itm%:=3;
    for i%:=0 to 4 do
        DlgReal(itm%,12,0.0,1e4,xp,yp,stp);             ' lowest edge at bottom
        yp-=1;
        itm%+=1;
    next;
    DlgButton(1,"OK|0x0d",MyOK%);
    DlgButton(0,"");                                    ' No <Cancel> button
    DlgShow(powpctchk%,trendchk%,edgeHz[]);
    for i%:=0 to 4 do
        edgeHz[i%]:=Round(edgeHz[i%]/bwHz)*bwHz;        ' adjust stored band edges to nearest bin margins
        edgebin[i%]:=(edgeHz[i%]/bwHz)+0.01;            ' equivalent bin position in spectrum (cf XtoBin())
        edgebin%[i%]:=edgebin[i%];
    next
    if edgeHz[0] < bwHz then
        edgeHz[0]:=bwHz;
        edgebin[0]:=1;
    endif;                                              ' always ignore the first bin of power spectrum
    hibin%[0]:=edgebin%[1]-1; lobin%[0]:=edgebin%[0]-1; ' band margins for power measurements
    hibin%[1]:=edgebin%[2]-1; lobin%[1]:=edgebin%[1]-1;
    hibin%[2]:=edgebin%[3]-1; lobin%[2]:=edgebin%[2]-1;
    hibin%[3]:=edgebin%[4]-1; lobin%[3]:=edgebin%[3]-1;     
    if trendchk% = 1 then	                         
        DoTrendplots%();
    endif;
endif;
ToolbarEnable(all%,on%);
setupdone%:=1;
return 1;
end;

func Idlbandsdlg%();                                    ' prevent user from setting invalid bands
var i%,nxt;
for i%:= 3 to 7 do
    if DlgValue(i%+1) <= DlgValue(i%)+Trunc(bwHz*100000.0)/100000.0 then
        nxt:=Trunc((DlgValue(i%)+bwHz)*100000.0)/100000.0;
        DlgValue(i%+1,nxt);        
    endif;
next;
return 1;
end;

func Stagebtnsdlg();
var ok%,i%,itm%:=1;
var x,xofs,y,yofs,w,h;
var grlbl$[4];                                          ' :={"Option 1","Option 2","Option 3","User defined"}; 8.03 and higher
grlbl$[0]:="Option 1"; grlbl$[1]:="Option 2"; grlbl$[2]:="Option 3"; grlbl$[3]:="User defined";
var lbl0$[7];                                           ' :={"Wake (0)","S&1","S&2","S&3","S&4","REM (5)","Other (6)"};
lbl0$[0]:="Wake (0)"; lbl0$[1]:="S&1"; lbl0$[2]:="S&2"; lbl0$[3]:="S&3"; 
lbl0$[4]:="S&4"; lbl0$[5]:="REM (5)"; lbl0$[6]:="Other (6)"; 
var lbl1$[5];                                           ' :={"Wake (&1)","NREM (&2)","REM (&3)","Mvment (&4)","Other (&5)"};
lbl1$[0]:="Wake (&1)"; lbl1$[1]:="NREM (&2)"; lbl1$[2]:="REM (&3)"; lbl1$[3]:="Mvment (&4)"; lbl1$[4]:="Other (&5)"; 
var lbl2$[5];                                           ' :={"Wake (&1)","SWS (&2)","REM (&3)","Mvment (&4)","Other (&5)"};
lbl2$[0]:="Wake (&1)"; lbl2$[1]:="SWS (&2)"; lbl2$[2]:="REM (&3)"; lbl2$[3]:="Mvment (&4)"; lbl2$[4]:="Other (&5)"; 

dd%:=7;
DlgCreate("Select Stage buttons",dxp[dd%],dyp[dd%]);
DlgAllow(511,0,Chnge%);

DlgText("button",62,2.2);                               ' labels
DlgText("label",71,2.2);

x:=3; y:=1; w:=15; h:=9;
for i%:=0 to 3 do
    if i%=3 then w+=5; endif;                           ' user-defined group is wider
    DlgGroup(grlbl$[i%],x,y,w,h);
    x+=18;
next;
x:=5; y:=2;
for i%:=1 to 4 do
    DlgCheck(itm%,"",x,y);                              ' stage selection checkboxes
    x+=18; itm%+=1;
next;

x:=6; y:=3;
for i%:=0 to 6 do
    DlgText(lbl0$[i%],x,y);                             ' option 1 labels
    y+=1;    
next;
x+=18; y:=3;
for i%:=0 to 4 do
    DlgText(lbl1$[i%],x,y);                             ' option 2 labels
    y+=1;    
next;
x+=18; y:=3;
for i%:=0 to 4 do
    DlgText(lbl2$[i%],x,y);                             ' option 3 labels
    y+=1;    
next;

x+=18; y:=3;
for i%:=0 to 6 do
    DlgString(itm%,8,8,"",x,y);                         ' option 3 labels
    itm%+=1;
    y+=1;    
next;
x+=10; y:=3;
for i%:=0 to 6 do
    DlgString(itm%,6,7,"",x,y);                         ' option 3 labels
    itm%+=1;
    y+=1;    
next;
DlgButton(1,"OK|0x0d",MyOK%);
DlgButton(0,"");                                        ' no <Cancel> button
ok%:=DlgShow(chk0%,chk1%,chk2%,chk3%,s$[],slab2$[]);
return ok%;
end;

func Chnge%(item%)                                      ' ensure that only one checkbox can be checked 
docase                                                  ' and that you cannot uncheck a checked box
case item% = 0 and DlgValue(4) <> 1 then
    DlgEnable(0,dit%[5:14]);                            ' disable user defined selection boxes
    
case item% = 1 and DlgValue(1) = 0 then                 ' user tried to uncheck the item
    Sound("S*",1);
    DlgValue(1,1);
case item% = 1 and DlgValue(1) = 1 then                 ' user checked an unchecked box
    DlgValue(2,0);DlgValue(3,0);DlgValue(4,0);          ' uncheck all the others
    DlgEnable(0,dit%[5:14]);                            ' disable user defined selection boxes
    
case item% = 2 and DlgValue(2) = 0 then
    Sound("S*",1);
    DlgValue(2,1);
case item% = 2 and DlgValue(2) = 1 then	
    DlgValue(1,0);DlgValue(3,0);DlgValue(4,0);
    DlgEnable(0,dit%[5:14]);                            ' disable user defined selection boxes
    
case item% = 3 and DlgValue(3) = 0 then
    Sound("S*",1);
    DlgValue(3,1);
case item% = 3 and DlgValue(3) = 1 then	
    DlgValue(1,0);DlgValue(2,0);DlgValue(4,0);
    DlgEnable(0,dit%[5:14]);                            ' disable user defined selection boxes
    
case item% = 4 and DlgValue(4) = 0 then
    Sound("S*",1);
    DlgValue(4,1);
case item% = 4 and DlgValue(4) = 1 then
    DlgValue(1,0);DlgValue(2,0);DlgValue(3,0);
    DlgEnable(1,dit%[5:14]);                            ' enable user defined selection boxes
endcase;
return 1;
end;

proc EvtbtnSelect();                                    ' set up event button and state labels
var i%;

for i%:=0 to 9 do
    if evlbl2$[i%]<> "" then
        evtypes%+=1;                                    ' count the number which were defined
    endif;
next;     
return;
end;

proc Selectbtns()                                       ' define labels for the selected set of staging buttons
var done%;

slab$[0]:="W";	slab$[1]:="NREM";	slab$[2]:="REM";       ' 	defaults state labels (option 2)
slab$[3]:="M";	slab$[4]:="?";	slab$[5]:="";	slab$[6]:="";

s2$[0]:= "Wake (&0)|0x30";	s2$[1]:= "NREM (&1)|0x31";   ' defaults button labels
s2$[2]:= "  REM (&2)|0x32";	s2$[3]:= "Mvment &3|0x33";
s2$[4]:= " Other (&4)|0x34";	s2$[5]:= "";	s2$[6]:= "";
nstates%:=4;
docase
case option% = 1 then 
    slab$[1]:="S1";	slab$[2]:="S2";	slab$[3]:="S3";     ' option 1 stage labels
    slab$[4]:="S4";	slab$[5]:="REM";	slab$[6]:="?";
    s2$[6]:= "Other (&6)|0x36";	s2$[5]:= "REM (&5)|0x35";	s2$[4]:= "     S&4    |0x34"; ' button labels
    s2$[3]:= "    S&3    |0x33";	s2$[2]:= "    S&2    |0x32";
    s2$[1]:= "    S&1    |0x31"; s2$[0]:= "Wake(&0)|0x30";
    nstates%:=6;                                        ' number of states in use (including <blank>)
    
case option% = 3 then                                   ' option 3 stage labels
    slab$[1]:="SWS";	s2$[1]:= " SWS (&1) |0x31";
    
case option% = 4 then                                   ' user defined buttons and stage labels
    ' how many buttons were defined?
    nstates%:=0;
    repeat
        if nstates%=7 then break; endif;
        if Len(slab2$[nstates%])=0 then break; endif;    
        nstates%+=1;                                    ' count the number of buttons that were defined
    until done%;
    nstates%-=1;        
    if nstates% < 4 then
        Newsflash("Warning: You must define at least 5 stage buttons\n Option 2 buttons will be used for now.",4.0,0,0,0);
        option%:=2;
        nstates%:=4;
    else
        for i%:=0 to nstates% do
            slab$[i%]:=slab2$[i%];                      ' copy the user-defined state
            s2$[i%]:=s$[i%];                            ' ..and button labels
        next;
    endif;
endcase;
return;
end;

func Back%();
var newch%;

if ViewKind(psvh%) = 4 then
    View(ps2vh%).WindowVisible(0);                      ' hide power spectrum
    View(LogHandle()).WindowVisible(0);                 ' hide log
endif;

View(timevh%);
if ChanKind(ssch%)=8 and InStr(Chan$(ssch%),"m")>0 then ' if ssCh is a memory buffer 
    newch%:=ChanSave(ssch%,0);    
    ChanOrder(ssch%,1,newch%);                          ' move newly created disk channel next to memory buffer
    ChanShow(newch%);                                   ' show it
    ChanDelete(ssch%);                                  ' delete buffer
    ssch%:=newch%;                                      ' keep same variable name for the channel
endif;
if ChanKind(mvmch%)=8 then ' if ssCh is a memory buffer 
    newch%:=ChanSave(mvmch%,0);    
    ChanOrder(mvmch%,1,newch%);                          ' move newly created disk channel next to memory buffer
    ChanShow(newch%);                                   ' show it
    ChanDelete(mvmch%);                                  ' delete buffer
    mvmch%:=newch%;                                      ' keep same variable name for the channel
    'MemSave(mvmch%,mvmch%,8);
endif;
if ChanKind(hypch%)=7 then
    newch%:=ChanSave(hypch%,0);                         ' save hypnogram to permanent channel
    ChanShow(newch%);
    ChanOrder(hypch%,1,newch%);
    ChanDelete(hypch%);
    hypch%:=newch%;
    ChanTitle$(hypch%,Print$("Hyp %d",ssch%));          ' update title with chan nr of source epoch chaannel
endif;

var list%[2];     

CursorDelete(1);                                        ' delete cursor
if Count(evtch%,0,MaxTime()) > 0 then                   ' something worth saving
    ' make the event channel permanent
    newch%:=ChanSave(evtch%,0,0);
    ChanOrder(ssch%,-1,newch%);                         ' next to stages channel
    ChanShow(newch%);
    ChanDelete(evtch%);
    evtch%:=newch%;
    if vmchk% then
        VerticalMark(evtch%,vmflags%,-1,-1,-1);
    endif;
else
    ChanDelete(evtch%);                                 ' delete events buffer if empty
endif;
ToolbarText("");
return 1;
end;

func SSshow%()                                          ' show current <Sleep Stage> selection
var i%,yp:=2;

DlgCreate("Current sleep stages",83,25,20);
DlgAllow(511);
DlgText("  #     Stage",0,1);
DlgGroup("",1,1.5,18,7.3);
for i%:=0 to 6 do
    DlgText(Print$(" %2d        %s",i%+1,s2$[i%]),0,yp);
    yp+=1;
next;
DlgButton(0,"");                                        ' no <Cancel> button
DlgShow();
return 1;
end;

func EvtShow%()                                         ' show current <Event> selection
var i%,yp:=2;

DlgCreate("Current Events",83,15,20);
DlgAllow(511);
DlgText("  #        Event",0,1);
DlgGroup("",1,1.5,18,10.3);
for i%:=0 to 9 do
    DlgText(Print$(" %2d        %s",i%+1,evbtnlbl2$[i%]),0,yp);
    yp+=1;
next;
DlgButton(0,"");                                        ' no <Cancel> button
DlgShow();
return 1;
end;

func Epochs%();                                         ' select time range and subdivide it into epochs
var ok%,swap,epch%,evch%,mvch%,t,epchlst%[10],evchlst%[10],mvchlst%[10];
View(timevh%);
epend:=MaxTime();

'offer existing event and epoch channels as defaults in the dialog but add alternative new channels to the list 
'so that user can opt to create new channels rather than updating existing ones
epch%:=MemChan(8,40);                                   ' create new textmark buffer for epochs
evch%:=MemChan(8,40);                                   ' create new textmark buffer for events
mvch%:=MemChan(8,40);  
                                ' create new textmark buffer for movements
ChanTitle$(epch%,"New Epochs");
ChanTitle$(evch%,"New Evts");

FChanList%(epchlst%[],32,"epoc",0);                     ' list of existing epoch channels
FChanList%(evchlst%[],32,"ev",0);                       ' look for an existing event channel 
FChanList%(mvchlst%[],32,"Movements",0);                       ' look for an existing movement channel 

epchlst%[0]+=4194304;                                   ' use short form channel titles in dialogs if poss.
evchlst%[0]+=4194304;

'If movement channel exists, use it.
if mvchlst%[0] > 0 then
    MemImport(mvch%,mvchlst%[1],0.0,MaxTime());            
    ChanTitle$(mvch%,"Movement");       
    ChanDelete(mvchlst%[1]);                             
    mvmch%:=mvch%; 
'Otherwise use the newly created memory channel    
else
    ChanTitle$(mvch%,"Movement");    
    mvmch%:=mvch%;
endif

dd%:=1;
DlgCreate("Set up Epochs",dxp[dd%],dyp[dd%],62);
DlgAllow(1023,Eidl%,Echnge%);
DlgText("Epoch channel",0,1);
DlgText("Events channel",0,2);
DlgChan(1,20,epchlst%[]);
DlgChan(2,20,evchlst%[]);	                         
DlgReal(5,"Epoch duration (s)",5.0,120.0,0,3,5);

DlgGroup("Time range",1,4,60,4);
DlgText("Start (s)",0,5);
DlgText("End (s)",0,6);
c1itm%:=3;  c2itm%:=4;
DlgReal(3,14,0,MaxTime(),-3,5,1);
DlgReal(4,14,0,MaxTime(),-3,6,1);
DlgText("TIP:    Drag vertical cursors to adjust the time range.",15,7.2);
DlgButton(2,"   Zero   ",C1Zero%,15,5);
DlgButton(3,"Fetch Csr1",FetchCsr1%,28,5);
DlgButton(4,"MaxTime",C2MaxT%,15,6);
DlgButton(5,"Fetch Csr2",FetchCsr2%,28,6);

DlgGroup("Sleep stages and Events",1,8.5,60,6);
DlgCheck(6,"Check to change stage buttons|Customise Stage buttons",0,9.5);
nt%[0]:=DlgText("Uncheck to use default stages",5,10.2); ' 11
DlgCheck(7,"Check to change Event buttons|Customise Event buttons",0,11.5);
nt%[1]:=DlgText("Uncheck to use default Events",5,12.2);
DlgCheck(8,"Generate a Hypnogram",0,13.5);
DlgCheck(9,"Enable banded power spectra",32,13.5);
DlgButton(6,"Show Stages",SSshow%,-5,9.8);
DlgButton(7,"Show Events",EvtShow%,-5,11.8);

DlgButton(1,"OK|0x0d",MyOK%);
DlgButton(0,"Cancel",MyCancel%);
ok%:=DlgShow(ssch%,evtch%,epstart,epend,epdur,swbtns%,evbtns%,hypchk%,psonoff%);
docase
case ok% <=0 then
    ChanDelete(epch%);                                  ' delete unwanted new epoch channel
    ChanDelete(evch%);                                  ' ditto new event channel
    ChanDelete(mvch%);
    return 0;                                           ' cancel pressed
case epstart > epend then
    swap:=epend;
    epend:=epstart;                                     ' swap start and end values
    epstart:=swap;
endcase;
if ssch% <> epch% then
    ChanDelete(epch%);                                  ' delete unwanted new epoch channel
else                                                    ' configure it
    ChanTitle$(ssch%,"Epochs");
    t:=epstart+tick;
    codes%[0]:=8;                                       ' assign all epochs to blank state
    comment$:="U ";                                     ' U: unclassified
    repeat
        MemSetItem(ssch%,0,t,codes%[],comment$);        ' add textmark at beginning of each epoch
        t+=epdur;
    until t >= epend;                                   ' MaxTime()-.001;                          ' make epochs for time range
    if t > MaxTime() - tick then
        t:= MaxTime();
        MemSetItem(ssch%,0,t,codes%[]);                 ' put terminating marker at end of file
    endif;
    DrawMode(ssch%,15,2);                               ' mark epochs as states with comment visible
    ChanShow(ssch%);                                    ' show it
endif;
if evtch% <> evch% then
    ChanDelete(evch%);
else
    DrawMode(evtch%,15,2);
endif;           ' delete temporary events channel
'Show the movement channel
DrawMode(mvmch%,15,2);
ChanShow(mvmch%);

XRange(epstart,epstart+trep%*epdur);                    ' set initial time range to epoch count specified in Preferences
return 1;
end;

func Echnge%(item%);                                    ' react to users selections in the Epochs dialog
var en%,t2,t1,ch%,ch$;                                      ' ,tst$;

if item% = 0 or item% =1 then
    ch%:=DlgValue(1);
    ch$:=Chan$(ch%);
    if Instr(ch$,"m")>0 then 'channel is a memory buffer.  fixed 26/09/2017
    'if ch% > 400 and ch% < 701 then                     ' fails in version 9
        en%:=1;                                         ' enable epoch duration item
        DlgEnable(1,6,nt%[0]);                          ' enable stage selection checkbox for existing epoch channels
    else
        en%:=0;                                         ' hide it
        t1:=NextTime(ch%,-1);
        t2:=NextTime(ch%,t1);
        epdur:=t2-t1;
        DlgValue(5,epdur);
        DlgEnable(redostagesflg%,6,nt%[0]);             ' disable stage selection checkbox for existing epoch channels
    endif;
    DlgEnable(en%,5);                                   ' disable epoch duration set if necessary
endif;

LinkDlgToCsr%(item%,c1itm%,1,timevh%);                  ' link times in dialog to cursor in source file
LinkDlgToCsr%(item%,c2itm%,2,timevh%);
CursorRenumber();
return 1;
end;

func Eidl%()
LinkCsrToDlg(c1itm%,1,timevh%);                         ' link cursors 1 and 2 in source file to the dialog
LinkCsrToDlg(c2itm%,2,timevh%);
if Cursor(1)>Cursor(2) then
    CursorRenumber();
endif;
return 1;
end;

func Commentbtn%();                                     ' add comment to sleep stage
View(timevh%);
CursorSet(1);
DlgCreate("Add Comment to an epoch",0,0,44);
DlgAllow(511,CmtIdl%);
DlgText("Comment",1,1);
DlgString(1,30,30);
DlgText("Drag cursor into the target epoch.",2,2);
DlgButton(0,"");                                        ' No <Cancel> button
DlgButton(1,"Close||Hotkey: <Enter>");
DlgButton(2,"Add Comment (F2)|0x71|Hotkey: <F2>",AddCmt%);
DlgShow(comment$);
return 1;
end;

func CmtIdl%()
var c$,l$,r$;

View(timevh%);
LastTime(ssch%,Cursor(1)+tick,codes%[],c$);             ' get comment at cursor position
if c$<>lastc$ then
    CommentSplit(c$,l$,r$);
    DlgValue$(1,r$);
    lastc$:=c$;
endif;
return 1;
end;

func AddCmt%()
var t,c$,l$,r$;

View(timevh%);
t:=LastTime(ssch%,Cursor(1)+tick,codes%[],c$);          ' get code and comment from the current epoch
CommentSplit(c$,l$,r$);
MarkEdit(ssch%,t,codes%[],Print$("%s %s",l$,DlgValue$(1))); ' reassembel stage label and new comment
return 1;
end;

func PSsetup%();
var done%;
View(timevh%);
repeat
    dd%:=8; 
    DlgCreate("Set up Spectrum analysis",dxp[dd%],dyp[dd%],65);
    DlgAllow(511,PSsetupIdle%,PSsetupChnge%);
    nt%[0]:=DlgText("Channel",2,1);
    nt%[1]:=DlgText("FFT size",40,1);
    nt%[2]:=DlgText("Window type",2,2);
    nt%[3]:=DlgText("T (s)",43,2);
    nt%[4]:=DlgText("Results will show frequencies from 0  to ...",5,5);
    nt%[5]:=DlgText("Number of bins ...",24,6);
    nt%[6]:=DlgText("of width ...",30,7);
    nt%[7]:=DlgText("Hz",58,5);
    nt%[8]:=DlgText("Hz",58,7);
    DlgChan(1,20,1+2048+131072+1048576+4194304,13,1);   ' visible waveforms+selected (short titles)
    DlgList(2,10," 16| 32| 64| 128| 256| 512| 1024| 2048| 4096| 8192|16384| 32768",12,-3,1); ' fft size
    DlgList(3,15," No window| Hanning| Hamming",3,18,2); ' window
    DlgReal(4,10,0,100.0,-3,2);                         ' fft duration
    DlgGroup("Info.",3,4,59,4);
    DlgReal(5,12,1,1e6,44,5);
    DlgInteger(6,12,0,20000,44,6);
    DlgReal(7,12,0,1000.0,44,7);
    DlgButton(1,"OK|0x0d",MyOK%);
    DlgButton(0,"");                                    ' No <Cancel> button
    DlgShow(PSchan%,fftszndx%,fftwinndx%,Tfft,uf,nbns%,bwHz);    
    
    docase
    case PSchan% = -3 and ChanSelect(-1) = 0 then       ' trap failure to select channels in Selected mode 
        done% := 0;
    case PSchan% = 0 then
        Newsflash("No channel(s) selected. Power spectrum mode will be disabled.",0,70,5,0); ' warning
        done%:=1;
    else
        done%:=1;
    endcase;
until done%;
if PSchan% = 0 or done% = 0 then                        ' no channel selected
    psonoff%:=0;                                        ' so, turn off power spectrum
endif;
return 1;
end;

func PSsetupIdle%();
ChanList(selchlst%[],1+512+65536);                      ' list selected waveform/realwave channels
if selchlst%[0] <> prev% then                           ' number of selected channels changed since we last checked
    updflag%:=1;                                        ' set a flag
    prev%:=selchlst%[0];
endif;
if DlgValue(1) = -3 and updflag% <> 0 then              ' selected channel chosen 
    PSsetupChnge%(1);                                   ' force the dialog to update
    updflag%:=0;                                        ' reset the flag
endif;
return 1;
end;

func PSsetupChnge%(item%);                              ' calculate binwidth FFTno. etc for currently selected channel
var val%,i%,ch%;

val%:=DlgValue(1);                                      ' get channel selection
ChanList(selchlst%[],1+512+65536);                      ' list selected waveform/realwave channels
if item% =0  then                                       ' first pass
    DlgEnable(0,2,3,4,5,6,7,nt%[1:8]);                  ' disable all except channel selector
endif;
docase
case item% =1 or val% <> 0 then                         ' changed channel selection
    docase
    case val% = 0 then                                  ' None
        Noneselected();
    case val% > 0 then                                  ' single channel
        ToolbarText("");                                ' clear old message
        DoBins(val%);
    case val% =-3 then                                  ' selected channels 
        docase
        case selchlst%[0] = 1 then                      ' single channel selected
            DoBins(selchlst%[1]);
        case selchlst%[0] > 1 then                      ' multiple channels selected
            var arr[selchlst%[0]],sum;                  ' check for compatibility
            for i%:=1 to selchlst%[0] do
                arr[i%-1]:=BinSize(selchlst%[i%]);      ' make array of sample intervals
            next;
            sum:=ArrSum(arr[]);
            if sum <> arr[0]*selchlst%[0] then          ' sampling rates differ
                Message("Sampling rate  is not the same for all selected channels.\nPlease try again.");
                ChanSelect(-1,0);                       ' un-select all channels
            else
                DoBins(selchlst%[1]);                   ' use parameters of first selected channel to set up the dialog
            endif;
        else                                            ' no channels selected
            Noneselected();
        endcase;
    endcase;
    
case item% = 7 then                                     ' FFT number changed
    if val% =-3 then ch%:=selchlst%[1]; else ch%:=val%; endif; ' cope with selected channel setting
    Dobins(ch%);                                        '  val can be -3 if fftsize changed on selected channel
endcase;
return 1;
end;

Proc NoneSelected();                                    ' no valid channel selected
var i%;

DlgEnable(0, 2,3,4,5,6,7,nt%[1:8]);                     ' disable all items except channel selector and Close button
for i%:=2 to 4 do
    DlgValue(i%,0);                                     ' zero the freq limit nbins and binwidth elements of dialog
next;
psonoff%:=off%;                                         ' switch off power spectrum analysis
NewsFlash("Click on channel numbers to select them.",2.5,70,15,0);
return;
end;

Proc DoBins(val%);                                      ' calculate values for f.limit and nbins blocksize and show in PSsetup dialog 
var uf,blocksz,nbns%,bw;

DlgEnable(1,2,3,nt%[1:8]);                              ' enable dialog items
uf:=0.5/BinSize(val%);                                  ' upper frequency limit is half the channel sample rate
nbns%:=fftnrarr%[DlgValue(2)]/2;                        ' number of bins is 1/2 the chosen FFT number selected from list
bw:=uf/nbns%;                                           ' binwidth is frequency/number of bins
blocksz:=2.0*nbns%*BinSize(val%);
DlgValue(6,nbns%);
DlgValue(5,uf);                                         ' show it
DlgValue(7,bw);                                         ' show in dialog
DlgValue(4,blocksz);
if blocksz > epdur then
    NewsFlash("Warning: FFT duration is longer than 1 epoch.\n"+
    "Please select a lower FFT number.",5.0,0,0,1);
    psonoff%:=off%;
else
    psonoff%:=on%;                                      ' switch on PS analysis
endif;
return;
end;

proc ProfileGet()
var i%,slbtns$,sllbls$,Bndedges$,evblbls$,evtlbls$,rscope$;

Profile(key$,"Epdur","30",epdur$);                      ' get current option for stage buttons
Profile(key$,"Sel btns",1,option%);                     ' get current option for stage buttons

var prevss$;                                            ' save last used sleep stage labels     (added Sept 2016 so we can show current selection in New Set up dialog)
Profile(key$,"prevSSBtns","",prevss$);                  ' stored ss buttons labels from previous run
ReadStr(prevss$,s2$[0],s2$[1],s2$[2],s2$[3],s2$[4],s2$[5],s2$[6]);

Profile(key$,"RptScope","1,1,0,0,1,1,0,0",rscope$);
ReadStr(rscope$,reptchk%[0],reptchk%[1],reptchk%[2],reptchk%[3],reptchk%[4],reptchk%[5],reptchk%[6],reptchk%[7]);

Profile(key$,"UDBtns","\"WAKE\",\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\"",slbtns$); ' get user-defined button labels
ReadStr(slbtns$,s$[0],s$[1],s$[2],s$[3],s$[4],s$[5],s$[6]);
Profile(key$,"UDlbl","\"WAKE\",\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\"",sllbls$); ' user-defined stage  labels  (Default: same as buttons)
ReadStr(sllbls$,slab2$[0],slab2$[1],slab2$[2],slab2$[3],slab2$[4],slab2$[5],slab2$[6]);                                                                               
Profile(key$,"PS onoff",0,psonoff%);                    ' 1:with power spectra; 0: no power spectra
Profile(key$,"PSch",0,pschan%);                         ' remember last power spectrum channel

Profile(key$,"Hypnogm",0,hypchk%);                      ' select hypnogram channel
Profile(key$,"FFTndx",5,fftszndx%);                     ' last used FFTsize
Profile(key$,"FFTwinndx",1,fftwinndx%);                 ' last used window type Hanning/Hamming etc.

Profile(key$,"BandEdges","2.0,4.0,7.5,13.5,35.0",Bndedges$); ' power band margins as strings
ReadStr(Bndedges$,edgeHz[0],edgeHz[1],edgeHz[2],edgeHz[3],edgeHz[4]);

Profile(key$,"Evbtns","\"Arousal|0x30|hotkey:  0\",\"ApneaO|0x31|hotkey:  1\",\"ApneaC|0x32|hotkey:  2\",\"Hypopnea|0x33|hotkey:  3\",\"Mixed|0x34|hotkey:  4\",\"HypC|0x35|hotkey:  5\","+
"\"HypO2%|0x36|hotkey:  6\",\"HypC2%|0x37|hotkey:  7\",\"HypOelse|0x38|hotkey:  8\",\"HypCelse|0x39|hotkey:  9",evblbls$); ' user-defined event button labels
ReadStr(evblbls$,evbtnlbl2$[0],evbtnlbl2$[1],evbtnlbl2$[2],evbtnlbl2$[3],evbtnlbl2$[4],evbtnlbl2$[5],evbtnlbl2$[6],evbtnlbl2$[7],evbtnlbl2$[8],evbtnlbl2$[9]);

Profile(key$,"EvLbls","\"AR\",\"ApO\",\"ApC\",\"HypO\",\"M\",\"HypC\",\"HypO2%\",\"HypC2%\",\"HypOx\",\"HypCx",evtlbls$); ' user-defined state labels
ReadStr(evtlbls$,evlbl2$[0],evlbl2$[1],evlbl2$[2],evlbl2$[3],evlbl2$[4],evlbl2$[5],evlbl2$[6],evlbl2$[7],evlbl2$[8],evlbl2$[9]);

Profile(key$,"powpct",0,powpctchk%);                    ' stored state of check boxes in power in bands dialog
Profile(key$,"trend",0,trendchk%);
Profile(key$,"scope",3,scope%);                         ' scope of report -default is everything (3)

for i%:= 0 to 4 do
    edgeHz$[i%]:=Print$("%f",edgeHz$[i%]);              ' read  real variables  into strings
next;
epdur :=Val(epdur$);
return;
end;

proc ProfileSet();
var i%,slbtns$,sllbls$,Bndedges$,evblbls$, evtlbls$,rscope$;

ReadSetup(",","","","","");
for i%:=0 to 4 do
    edgeHz$[i%]:=Print$("%.2f",edgeHz[i%]);             ' store as strings to 2 significant figures
next;
epdur$:=Str$(epdur);                                    ' store current epoch duration as string
Profile(key$,"Sel btns",option%);                       ' use this button set as default next time

var prevss$;                                            ' save last used sleep stage labels     (added Sept 2016 so we can show current selection in New Set up dialog)
prevss$:=Print$("\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"",s2$[0],s2$[1],s2$[2],s2$[3],s2$[4],s2$[5],s2$[6]);
Profile(key$,"prevSSBtns",prevss$);                     ' stored ss buttons labels from previous run

rscope$:=Print$("%d,%d,%d,%d,%d,%d,%d,%d",reptchk%[0],reptchk%[1],reptchk%[2],reptchk%[3],reptchk%[4],reptchk%[5],reptchk%[6],reptchk%[7]);
profile(key$,"RptScope",rscope$);                       ' save states of report scope checkboxes 

slbtns$:=Print$("\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"",s$[0],s$[1],s$[2],s$[3],s$[4],s$[5],s$[6]);
Profile(key$,"UDBtns",slbtns$);                         ' user-defined button labels
sllbls$:=Print$("\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"",slab2$[0],slab2$[1],slab2$[2],slab2$[3],slab2$[4],slab2$[5],slab2$[6]);
Profile(key$,"UDlbl",sllbls$);                          ' user-defined button labels

Profile(key$,"PS onoff",psonoff%);                      ' remember power spectrum selection next time
Profile(key$,"PSch",pschan%);                           ' remember power spectrum channel

Profile(key$,"Hypnogm",hypchk%);                        ' set hypnogram channel
Profile(key$,"FFTndx",fftszndx%);                       ' store FFTsize as default for next time
Profile(key$,"FFTwinndx",fftwinndx%);                   ' store window type as default for next time
Profile(key$,"Epdur",epdur$);                           ' store current epoch for next time
Profile(key$,"scope",scope%);                           ' scope of report

for i%:= 0 to 4 do
    edgeHz[i%]:=Val(edgeHz$[i%]);                       ' read strings into real variables
next;
Bndedges$:=Print$("%f,%f,%f,%f,%f",edgeHz[0],edgeHz[1],edgeHz[2],edgeHz[3],edgeHz[4]);
Profile(key$,"BandEdges",Bndedges$);                    ' store power band margins as strings

evblbls$:=Print$("\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s",evbtnlbl2$[0],evbtnlbl2$[1],evbtnlbl2$[2],evbtnlbl2$[3],evbtnlbl2$[4],
evbtnlbl2$[5],evbtnlbl2$[6],evbtnlbl2$[7],evbtnlbl2$[8],evbtnlbl2$[9]);
Profile(key$,"Evbtns",evblbls$);                        ' user-defined event button labels

evtlbls$:=Print$("\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s",evlbl2$[0],evlbl2$[1],evlbl2$[2],evlbl2$[3],evlbl2$[4],
evlbl2$[5],evlbl2$[6],evlbl2$[7],evlbl2$[8],evlbl2$[9]);
Profile(key$,"EvLbls",evtlbls$);                        ' user-defined state labels

Profile(key$,"powpct",powpctchk%);                      ' stored state of check boxes in power in bands dialog
Profile(key$,"trend",trendchk%);
return;
end;

func FetchCsr%()
View(timevh%);
CursorSet(1,XLow()+(XHigh()-XLow())*0.5);
CursorLabel(4,1,"Evt");
CursorLabelPos(1,10);                                   ' cascade labels
return 1;
end;

func EvtBtnsDlg();
var sc$[10],evtip$[10],evb$[10];
var i%,yp:=2;

ReadSetup("","","","","|");
for i%:=0 to 9 do
    ReadStr(evbtnlbl2$[i%],evb$[i%],sc$[i%],evtip$[i%]); ' split each event button label into its 3 components
next;
dd%:=2;
DlgCreate("Define Event buttons",dxp[dd%],dyp[dd%],0,0,0,1);
DlgAllow(511);
DlgText("Button label",3,1);
DlgText("Short Cut",18,1);
DlgText("Tool tip",30,1);
DlgText("State label",52,1);
for i%:=1 to 10 do
    DlgString(i%,12,12,"",3,yp);
    yp+=1;
next;
yp:=2;
for i%:=11 to 20 do
    DlgString(i%,6,6,"",20,yp);
    yp+=1;
next;
yp:=2;
for i%:=21 to 30 do
    DlgString(i%,20,20,"",30,yp);
    yp+=1;
next;
yp:=2;
for i%:=31 to 40 do
    DlgString(i%,6,6,"",54,yp);
    yp+=1;
next;
DlgButton(0,"");                                        ' no <Cancel> button
DlgButton(1,"OK|0x0d",MyOk%);                           ' ok remembers dialog position
DlgShow(evb$[],sc$[],evtip$[],evlbl2$[]);

for i%:=0 to 9 do
    evbtnlbl2$[i%]:=Print$("%s|%s|%s",evb$[i%],sc$[i%],evtip$[i%]); ' re-assemble event button label
next;

return 1;
end;

func VPwrInBand%(sch%,bw,lowHz,hiHz,epdur,col%,ttl$);
var vch%, expr$;

expr$:=Print$("Pw(%d,%f,%f,%f)",sch%,bw,lowHz,hiHz); 
vch%:=VirtualChan(0,expr$,0,epdur);
ChanColour(vch%,1,col%);
Drawmode(vch%,16);                                      ' skyline mode
ChanUnits$(vch%,Print$("%s^2",ChanUnits$(sch%)));
ChanTitle$(vch%,Print$("%s(%d)",ttl$,sch%));            ' include source channel number in the title
ChanComment$(vch%,"based on ch: "+Str$(sch%)+"; "+ChanTitle$(sch%));
Optimise(vch%);
ChanProcessAdd(vch%,4,-epdur);                          ' time shift by one epoch so that skyline level represents  the current epoch
ChanShow(vch%);
return vch%;
end;

func VPwrTot%(sch%,ach%,bch%,cch%,dch%,col%,ttl$)       ' total power in bands by adding individual bands
var vch%, expr$;

expr$:=Print$("ch(%d)+ch(%d)+ch(%d)+ch(%d)",ach%,bch%,cch%,dch%); 
vch%:=VirtualChan(0,expr$,0,epdur);
ChanColour(vch%,1,col%);
Drawmode(vch%,16);                                      ' skyline mode
ChanUnits$(vch%,ChanUnits$(ach%));
ChanTitle$(vch%,Print$("%s(%d)",ttl$,sch%));            ' include source channel number in the title
ChanComment$(vch%,"based on ch: "+Str$(sch%)+"; "+ChanTitle$(sch%));
Optimise(vch%);
ChanShow(vch%);
return vch%;
end;

func DoTrendPlots%();                                   ' plot power in bands as groups of realwave channels in the time view
var j%,i%;
var list%[20],chlst%[21];
var nsel%;

View(timevh%);
if PSchan%>0 then
    nsel%:=1; list%[0]:=1; list%[1]:=pschan%;           ' if a single eeg channel was selected
else
    nsel%:=ChanList(list%[],65536);                     ' if one or more  selected channels
endif;

for i%:=0 to 4 do
    FChanList%(chlst%[],512+2048,ttl$[i%],0);           ' delete pre-existing visible trend channels
    ChanDelete(chlst%[]);
next;

var tch%[nsel%][5],dest%[5];                            ' trend channels  4 bands +total power
for j%:=0 to nsel%-1 do
    for i%:=0 to 3 do
        tch%[j%][i%]:=VPwrInBand%(list%[j%+1],bwHz,edgeHz[i%],edgeHz[i%+1],epdur,col%[i%],ttl$[i%]); ' virtual power in band channels
    next;
    ArrConst(dest%[1:],tch%[j%][1:]);
    dest%[0]:=3;
    ChanOrder(tch%[j%][0],0,dest%[]);                   ' overdraw all bands for each source channel
    YAxisLock(tch%[j%][0],1,0);
    Optimise(tch%[j%][0]);                              ' optimise overdrawn group for current x-range
    VPwrTot%(list%[j%+1],tch%[j%][0],tch%[j%][1],tch%[j%][2],tch%[j%][3],39,ttl$[i%]);
next;     
return 1;
end;

func GetMax(array[]);                                   ' return the maximum value in an array
var ndx%,mx;
ndx%:=Max(array[]);
mx:=array[ndx%];
return mx;
end;

func GroupOptimise%();                                  ' customise power-in-bands trend channels 
var mn,mx,yhi,sellist%[2],ch%[10],selspec%[20],NinGroup%,t;
ArrConst(selspec%[],0);
View(timevh%);
ChanList(sellist%[],512+65536);                         ' selected real wave channels
if sellist%[0] = 0 then
    NewsFlash("No Power-in-bands channels selected.\n Hold down Ctrl and click on a channel number in each group to optimise, then retry.",2,0,0,0); ' none found
    return 1;
endif;
repeat
    NinGroup%:=ChanOrder(sellist%[1],0);                ' part of a group?
    if NinGroup% > 0 then                               ' yes
        yhi:=0.0;
        for i%:=1 to NinGroup% do
            ch%[i%-1]:=ChanOrder(sellist%[1],i%);       ' get chan nr.s of group members
            t:=LastTime(ssch%,XLow());                  ' make sure the leftmost level of skyline is included
            MinMax(ch%[i%-1],t,XHigh(),mn,mx);          ' get max value
            if mx > yhi then yhi:=mx; endif;            ' return max in window of grouped channels
            if ChanSelect(ch%[i%-1])=1 then
                selspec%[0]+=1;                         ' item count in element 0
                selspec%[selspec%[0]]:=ch%[i%-1];       ' add to spec and then unselect it
                ChanSelect(ch%[i%-1],0);
            endif; 
        next;
        for i%:=1 to NinGroup% do
            YRange(ch%[i%-1],0.0,yhi);                  ' common scale for all channels in group
        next;
    else
        selspec%[0]+=1;                                 ' item count in element 0
        selspec%[selspec%[0]]:=ch%[i%-1];               ' add to spec
        ChanSelect(ch%[i%],0);                          ' unselect channels that were processed
    endif;
    ChanList(sellist%[],512+65536);
until sellist%[0]=0;
for i%:= 1 to selspec%[0] do
    ChanSelect(selspec%[i%],1);                         ' restore selections
next;
return 1;
end;

func ChanCount%();                                      ' count number of channels available in data file for storing sleep score results
var list%[2],nch%,nch2%;
nch%:=ChanList(list%[],1023-256+8192+16384);            ' get upper limit for permanent channels 
nch2%:=ChanList(list%[],128);                           ' count unused disk channels
if nch% =32 and nch2% < 4 then
    Message("Warning:|Only "+Str$(nch2%)+" disk channels left.\n"+
    "Please use the 'Export as' option on the Spike2 file menu to create \n"+
    "a new file with more channels available to save sleep score data.\n"+
    "Then run the script again.");
    return 0;
else;
    Newsflash("Maximum allowed number of disk channels: "+Str$(nch%)+
    "\nNumber of available disk channels: "+Str$(nch2%),6.0,0,0,0);
endif;
return 1;
end;

